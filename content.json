{"meta":{"title":"从0.1开始学Android","subtitle":"zyf的Android学习笔记","description":"Android Tutorial","author":"Winfrid Zhao","url":"http://zyfAndroid.com"},"pages":[],"posts":[{"title":"Android第六课——活动的生命周期","slug":"Android第六课——活动的生命周期","date":"2018-08-14T01:52:21.000Z","updated":"2018-08-14T02:10:06.256Z","comments":true,"path":"2018/08/14/Android第六课——活动的生命周期/","link":"","permalink":"http://zyfAndroid.com/2018/08/14/Android第六课——活动的生命周期/","excerpt":"","text":"活动的生命周期返回栈Android使用任务(Task)来管理活动。一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack)。启动新活动时，该活动入栈，居于栈顶。按下Back键或调用finish()方法销毁活动时，处于栈顶的活动出栈，前一个入栈的活动居于栈顶。系统总是显示处于栈顶的活动给用户。 活动状态每个活动在生命周期内最多有4种状态。 运行状态：活动位于返回栈栈顶时。系统最不愿意回收这种状态的活动。 暂停状态：活动不再处于栈顶但依然可见时（比如处在对话框活动之下的活动）。系统也不愿意回收此类活动。 停止状态：活动不在栈顶且完全不可见时。系统仍会为其保存相应的状态和成员变量，但当需要内存时有可能会被系统回收。 销毁状态：活动从返回栈移除后。系统最倾向于回收此类活动。 活动生存期Activity类中提供了7个回调方法，可将活动的生命周期分成3个生存期。 完整生存期：在创建新活动时调用的onCreate()方法和销毁活动时调用的onDestory()方法之间的周期。 可见生存期：活动在由不可见变为可见时调用onStart()方法和在完全不可见时调用onStop()方法之间的周期。 前台生存期：活动在处于运行状态，准备好与用户交互时调用onResume()方法与活动被挂起，系统准备去启动或恢复另一活动时调用onPause()方法之间的周期。onPause()方法中通常释放一些消耗CPU的资源，保存一些关键数据，但方法执行速度一定要快。 onRestart()方法负责把活动从停止状态恢复为运行状态，即从onStop()后的活动执行，之后会执行onStart()方法。 在活动被回收前保存临时数据 Activity类中提供了一个onSaveInstanceState()回调方法，该方法可以保证在活动被回收之前一定会被调用。 该方法会携带一个Bundle类型的参数。Bundle提供了一系列方法用于保存数据，比如用putString()方法保存字符串，用putInt()方法保存整形数据，以此类推。 每个保存方法需要两个参数：键，相当于成员名，变量名，用于之后从Bundle中取值；第二个参数是要保存的值。 只需在onCreate()方法中传入之前保存的Bundle就可以在方法中取出之前保存的值。 可以把Bundle存放在Intent里实现跨活动传递数据。 活动的启动模式 主要是决定返回栈与返回栈中活动实例个数的设置，一共有四种，分别是standard,singleTop,singleTask,singleInstance，可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性选择启动模式。 standard模式下，每当启动一个新的活动，系统就会创建一个新的实例，它会入栈且处于栈顶。换句话说，standard模式对活动在返回栈中的唯一性不做任何保证。 用this.toString()方法可以把当前活动实例转换成字符串。 singleTop模式下，在启动活动时如果发现返回栈栈顶已经是该活动的一个实例则不再启动新活动。 singleTask模式下，在启动活动时如果发现返回栈中存在该活动实例则将其上所有活动都出栈使其置顶。 实际上我们在使用时发现，对于设置了”singleTask”启动模式的Activity，它在启动的时候，会先检测系统中属性值affinity等于它的属性值taskAffinity的task是否存在；如果存在这样的task，它就会在这个task中启动，否则就开启一个新的task。而taskAffinity默认情况下是应用的包名，即默认时并不会新建一个task。 因此，如果我们想要设置了”singleTask”启动模式的Activity在新的task中启动，就要为它设置一个独立的taskAffinity属性值。下面的代码中，应用程序的包名是com.fred.testactivity，我们将BActivity的启动模式设置成singleTask, 同时设置其taskAffinity属性为com.fred.testactivity.BActivity 。当BActivity启动时，会发现多了一个task 。代码如下：123456 &lt;activity android:name=\".BActivity\" android:label=\"@string/title_activity_b\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.fred.testactivity.BActivity\"&gt;&lt;/activity&gt; ==注== 此时该活动实例将会从停止/暂停状态恢复至运行状态，注意与活动生命周期结合理解。 singleInstance模式下，在整个系统中都只存在一个实例，因为系统会为该活动实例创建一个单独的返回栈。 使用getTaskId()可以获取当前任务ID的字符串。 关于活动的技巧知道当前界面对应的活动 用一个普通Java类作为AppCompatAvtivity的父类(e.g.BaseActivity)，再让所有活动都继承该类，在该类中重写onCreate()方法，打印一条以getClass().getSimpleName()作为内容的日志即可。getSimpleName()为获取当前类的简写名。 随时随地退出程序 新建一个Activity列表类，在其中写添加、去除Activity项以及借助finish()方法来结束列表中所有Activity的静态方法（e.g.finishAll()，静态是为了无需创建列表的实例） 在之前的BaseActivity中重写onCreate()和onDestroy()方法，加入在列表中添加、删除活动的方法调用。 接下来只需在需要结束所有活动的地方调用finishAll()方法即可。 也可以在finishAll()方法后加上杀掉当前进程的代码保证程序完全退出123android.os.Process.killProcess(android.os.Process.myPid());//killProcess()方法只能杀掉自己//通过myPid()方法获取当前进程的id 启动活动的更好方法 在活动中自己写一个actionStart()方法，在方法中通过传入的参数完成构建启动活动的Intent和调用startActivity()。 这样的好处在于可以清楚地看到需要传递的数据有哪些，而且在需要启动活动时只需调用该方法，无需再自己创建Intent等。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第六课","slug":"第六课","permalink":"http://zyfAndroid.com/tags/第六课/"},{"name":"Activity","slug":"Activity","permalink":"http://zyfAndroid.com/tags/Activity/"},{"name":"生命周期","slug":"生命周期","permalink":"http://zyfAndroid.com/tags/生命周期/"}]},{"title":"Android第五课——进阶组件之Intent初探","slug":"Android第第第五课——进阶组件之Intent初探","date":"2018-08-13T02:58:46.000Z","updated":"2018-08-13T04:59:42.849Z","comments":true,"path":"2018/08/13/Android第第第五课——进阶组件之Intent初探/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第第第五课——进阶组件之Intent初探/","excerpt":"","text":"Intent Intent 会在运行时将各个组件相互绑定（您可以将 Intent 视为从其他组件请求操作的信使），无论组件属于您的应用还是其他应用。 Intent是Android程序中各组件之间交互的重要方式，不仅可指明当前组件想要的动作，还能在不同组件间传递数据。 Intent包含的部分：组件名称，操作，数据，类别，Extra，标志 显式Intent 显式Intent指定明确的上下文和要转到的活动的class对象12345678Intent(Context packageContext, Class&lt;&gt; cls)//第二个参数指定想要启动的目标活动button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125; &#125;); 隐式Intent 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 隐式Intent不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。创建隐式Intent时,Android系统通过将Intent的内容与在设备上其他应用的清单文件中声明的Intent过滤器进行比较，从而找到要启动的相应组件。如果Intent与Intent过滤器匹配，则系统将启动该组件，并向其传递Intent对象。如果多个Intent过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。 Intent过滤器是应用清单文件中的一个表达式，它指定该组件要接收的Intent类型。例如，通过为Activity声明Intent过滤器，您可以使其他应用能够直接使用某一特定类型的Intent启动Activity。同样，如果您没有为Activity声明任何Intent过滤器，则Activity只能通过显式Intent启动。只有Intent过滤器的action标签与catogory标签同时与Intent中指定的action和category匹配时活动才能响应该Intent。12345678910button1.setOnClickListener(new View.OnClickListener()&#123; @override public void onClick(View v)&#123; Intent intent = new Intent(\"com.example.activitytest.ACTION_START\"); //此处使用Intent的另一个构造函数，传入action字符串即可。 startActivity(intent); //\"android.intent.category.DEFAULT\"是一种默认的category，调用startActivity()方法时会自动将其添加到Intent中。 //或intent.addCategory(\"categoryName\");来添加category &#125;&#125;); 还可以利用隐式Intent启动其他应用程序内的活动，比如分享到其他App，打开网页等操作。 12345678910button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); //这是Android系统内置的一个动作，其常量值为android.intent.action.VIEW intent.setData(Uri.parse(\"http://www.baidu.com\")); //通过Uri.parse()方法将网址字符串解析成Uri对象，使用setData()方法把URI赋给Intent。（Intent的Data使用URI来表示） startActivity(intent); &#125; &#125;); 在AndroidManifest.xml文件中，可以为活动的Intent过滤器指定额外的&lt;data&gt;标签限定活动能响应的URI类型。只有&lt;data&gt;标签中指定的内容和Intent中携带的Data完全 一致时，当前活动才能够响应该Intent。以下是常用的标签内容： android:scheme。用于指定数据的协议部分，如http，geo(地理位置)，tel(拨打电话)等。 android:host。用于指定数据的主机名部分，如www.baidu.com。 android:port。用于指定数据的端口部分，一般紧随在主机名之后。 android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 可以使用Intent在启动活动的同时传递数据。 把需要传递的数据用putExtra()方法存放在Extra中 在另一个活动中用getIntent()方法取得传来的Intent 用getStringExtra()方法取回数据（其他类型类似） 也可以使用Intent给上一个活动返回数据。开发文档中有一个startActivityForResult()方法用于启动活动并向上一个活动返回数据。 给它传递一个启动活动用的Intent和一个唯一的requestCode参数 在另一个活动中用另一个Intent的Extra携带要返回的信息 用setResult()方法设置传回Intent和结果（RESULT_OK或RESULT_CANCELED） 用finish()方法结束当前活动并传回Intent 返回到上一个活动后会回调onActivityResult()方法，重写该方法添加从中得到返回的数据的逻辑 注意“返回到上一个活动时”包含所有返回的情况，如按Back键等，在按Back键返回的情况下需要重写onBackPressed()方法来执行setResult()方法。（此时super.onBackPressed()要写在最后） 更多Intent的例子会在之后的广播中遇到。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第五课","slug":"第五课","permalink":"http://zyfAndroid.com/tags/第五课/"},{"name":"Intent","slug":"Intent","permalink":"http://zyfAndroid.com/tags/Intent/"}]},{"title":"Android第四课——进阶组件之Toast与菜单","slug":"Android第四课——进阶组件之Toast与菜单","date":"2018-08-13T02:54:08.000Z","updated":"2018-08-13T02:56:45.845Z","comments":true,"path":"2018/08/13/Android第四课——进阶组件之Toast与菜单/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第四课——进阶组件之Toast与菜单/","excerpt":"","text":"进阶组件Toast12345678910//Toast是android.widget包内的类//makeText是Toast的静态方法，返回一个按照参数生成的ToastToast toast = Toast.makeText(context, text, duration);toast.show();//context相当于一个场景、情景，application/service/activity都是它的子类//text是要显示的文本//duration是持续时间，有Toast.LENGTH_SHORT和Toast.LENGTH_LONG两个内置常量可选Toast.makeText(FirstActivity.this, \"text\", Toast.LENGTH_SHORT).show();//先执行makeText()方法，其返回的Toast对象再执行show()方法 需要为Toast设置触发条件。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); //用findViewById()方法找到button1(view类)，再转换成button类 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this, \"You clicked Button 1\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 改变Toast的位置 123456Toast toast = Toast.makeText(context, text, duration);toast.setGravity(Gravity.TOP|Gravity.LEFT, 0, 0);toast.show();//让Toast出现在容器的左上角//Gravity是Object的子类，有TOP/BOTTLE/LEFT/RIGHT/CENTER等常用int常量//第二、第三个参量是向右、向下移动Toast的偏移量 菜单菜单资源 需要在res/menu下建立菜单资源文件12345678&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/add_item\" android:title=\"Add\"/&gt; &lt;item android:id=\"@+id/remove_item\" android:title=\"Remove\"/&gt; &lt;/menu&gt; 部署菜单 重写onCreateOptionsMenu()方法创建菜单 123456public boolean onCreateOptionsMenu(Menu menu) &#123; //传入一个menu变量 getMenuInflater().inflate(R.menu.main, menu); //先调用getMenuInflater()方法得到MenuInflater对象 //再调用它的inflate()方法创建menu实例 return true;//方法中创建的菜单可见&#125; 重写onOptionsItemSelected()方法定义菜单响应事件 123456789101112public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123;//调用getItemId()方法得到被点击的菜单项ID case R.id.add_item: Toast.makeText(this, \"You clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, \"You clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第四课","slug":"第四课","permalink":"http://zyfAndroid.com/tags/第四课/"},{"name":"Toast","slug":"Toast","permalink":"http://zyfAndroid.com/tags/Toast/"},{"name":"菜单","slug":"菜单","permalink":"http://zyfAndroid.com/tags/菜单/"}]},{"title":"Android第三课——测试与调试","slug":"Android第三课——日志工具Logcat的使用","date":"2018-08-12T05:27:37.000Z","updated":"2018-08-12T05:28:45.774Z","comments":true,"path":"2018/08/12/Android第三课——日志工具Logcat的使用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第三课——日志工具Logcat的使用/","excerpt":"","text":"测试与调试log类与logcat工具分类 Log.v()，对应verbose级别，最低的日志级别 Log.d()，对应debug级别，运行时会被去掉 Log.i()，对应info级别 Log.w()，对应warn级别 Log.e()，对应error级别用法 传入两个字符串参数 tag，一般传入当前的类名即可，用于对打印信息进行过滤 msg，想要打印的具体内容 输入logX按TAB即可补全对应的方法。 在onCreate()方法外输入logt按TAB即可生成当前类名的tag常量。 可以在logcat中用关键字进行进一步过滤日志，关键字支持正则表达式。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第三课","slug":"第三课","permalink":"http://zyfAndroid.com/tags/第三课/"},{"name":"日志","slug":"日志","permalink":"http://zyfAndroid.com/tags/日志/"},{"name":"logcat","slug":"logcat","permalink":"http://zyfAndroid.com/tags/logcat/"}]},{"title":"Android第二课——构建简单的应用","slug":"Android第二课——构建简单的应用","date":"2018-08-12T05:16:22.000Z","updated":"2018-08-12T05:18:38.234Z","comments":true,"path":"2018/08/12/Android第二课——构建简单的应用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第二课——构建简单的应用/","excerpt":"","text":"编写应用一个最简单的app主代码12345678public class HelloWorldActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.hello_world_layout); //R类是自动生成的，包含所有res目录下资源的id &#125;&#125; AppCompatActivity是一种向下兼容的Activity,是Activity的子类。Activity是Android系统提供的一个活动基类，所有活动必须继承它或它的子类才拥有活动的特性。 onCreate()方法是创建活动时必定会执行的方法。 setContentView()方法为当前活动引入布局。Android程序的设计讲究逻辑与视图分离，因此常在布局文件中编写界面，然后在活动中引入。 使用finish()方法销毁活动。 layout文件123456789101112131415161718192021222324&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/hello_world_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.example.helloworld.HelloWorldActivity\"&gt; &lt;Button android:id=\"@+id/button_1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button 1\" /&gt;&lt;!--引用id用@id/name语法，定义id用@+id/name语法-&gt;&lt;!--TextView为文本--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; &lt;/RelativeLayout&gt; 资源——字符串123&lt;resources&gt; &lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt; &lt;/resources&gt; 引用资源的方式 代码中：通过R.string.app_name引用该字符串。 XML中：通过@string/app_name引用该字符串。\\其中string部分可替换成需要引用的资源类型，如layout,drawable等。例见AndroidManifest.xml文件。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第二课","slug":"第二课","permalink":"http://zyfAndroid.com/tags/第二课/"},{"name":"资源","slug":"资源","permalink":"http://zyfAndroid.com/tags/资源/"}]},{"title":"Android第一课——初识Android","slug":"undefined-2018-08-12","date":"2018-08-12T04:24:28.000Z","updated":"2018-08-12T04:31:22.678Z","comments":true,"path":"2018/08/12/undefined-2018-08-12/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/undefined-2018-08-12/","excerpt":"","text":"Android四大组件Activity活动 包含应用所有看得见的东西Service服务 无法看到，在后台运行，退出应用仍可继续运行Broadcast Receiver广播接收器 允许应用接收来自各处的消息，如电话、短信等。应用也可发出自己的广播消息。Content Provider内容提供器 程序间共享数据的方法 Android工程的结构 AndroidManifest.xml12345678910111213141516171819202122&lt;!--注意application标签要写在所有其他标签之后--&gt;&lt;activity android:name=\".HelloWorldActivity\" android:label=\"Title\"&gt;&lt;!--程序包名可省略--&gt; &lt;intent-filter&gt; &lt;!--在intent-fliter中指示该应用可以处理的intent类型--&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;!--action和category两行表示该活动为主活动--&gt; &lt;!--可选用data标签指定当前活动能响应的数据类型--&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; ... &lt;/application&gt; build.gradle~\\build.gradle12345678910111213buildscript &#123; repositories &#123; jcenter()//jcenter是一个代码托管仓库，有这一行就可以引用上面的开源项目 &#125; dependencies &#123; classpath 'com.android.tools.build: gradle:2.2.0' &#125; &#125; allprojects &#123; repositories &#123; jcenter() &#125; &#125; ~\\app\\src\\build.gradle1234567891011121314151617181920212223242526272829303132apply plugin:'com.android.application' //表示这是应用程序模块//com.android.library表示库模块android &#123;//android闭包 compileSdkVersion 24 buildToolsVersion \"24.0.2\" defaultConfig &#123; applicationId \"com.example.helloworld\" //包名 minSdkVersion 15 //最低兼容版本 targetSdkVersion 24 //做过充分测试的版本 versionCode 1//版本号 versionName \"1.0\"//版本名 &#125; buildTypes &#123; release &#123; minifyEnabled false//是否对项目代码混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; &#125; dependencies &#123; compile fileTree(dir:'libs', include:['*.jar']) //本地依赖声明 compile 'com.android.support:appcompat-v7:24.2.1' //远程依赖库 //com~support是域名 //app~v7是组名 //24.2.1是版本号 //库依赖：compile project(':libraryxxx') testCompile 'junit:junit:4.12'//测试用例库&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"工程","slug":"工程","permalink":"http://zyfAndroid.com/tags/工程/"},{"name":"结构","slug":"结构","permalink":"http://zyfAndroid.com/tags/结构/"},{"name":"第一课","slug":"第一课","permalink":"http://zyfAndroid.com/tags/第一课/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-12T02:24:45.393Z","updated":"2018-08-12T05:31:19.240Z","comments":true,"path":"2018/08/12/hello-world/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/hello-world/","excerpt":"","text":"这里是我的Android开发学习笔记。我使用Android Studio + Java进行开发，以郭霖的《第一行代码》为主要参考资料，辅以Android官方文档及网上其他资料。 由于本人纯小白，也会在此发表一些Java学习笔记。因为本人处在不断学习的阶段，之前发表的文章也可能会更新内容。 本博客使用Hexo 搭建。","categories":[],"tags":[]}]}