{"meta":{"title":"从0.1开始学Android","subtitle":"zyf的Android学习笔记","description":"Android Tutorial","author":"Winfrid Zhao","url":"http://zyfAndroid.com"},"pages":[],"posts":[{"title":"Android实战记（一）——用ConnectivityManager管理网络连接","slug":"Android实战记（一）——用ConnectivityManager管理网络连接","date":"2018-08-15T02:39:57.000Z","updated":"2018-08-17T03:19:01.404Z","comments":true,"path":"2018/08/15/Android实战记（一）——用ConnectivityManager管理网络连接/","link":"","permalink":"http://zyfAndroid.com/2018/08/15/Android实战记（一）——用ConnectivityManager管理网络连接/","excerpt":"","text":"最近看《第一行代码》看到了广播那一章，跟着书写到动态注册监听网络变化的那一节。其中一段代码如下：123456789101112131415public class MainActivity extends AppCompatActivity &#123; ... class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ConnectivityManager connectionManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, \"network is available\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, \"network is unavailable\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; 在参考官方文档)时，偶然发现上述代码中使用的Network.onAvailable()方法在API 28也就是Android P被摒弃了，官方转而推荐使用ConnectivityManager.NetworkCallbackAPI来监听网络变化。既然如此，我就想了解一下官方推荐的方法怎么使用。 查阅了种种资料之后，我写了第一个版本试试看（最小SDK为Android M）：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); connMgr.registerNetworkCallback(networkRequest, networkCallback); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); connMgr.unregisterNetworkCallback(networkCallback);//此处这句可以不写，可以理解为退出应用后会自动取消注册 &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); Toast.makeText(getBaseContext(), \"网络正常\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); Toast.makeText(getBaseContext(), \"网络已断开\", Toast.LENGTH_SHORT).show(); &#125; &#125; Java基础比较深或者对UI编写中给View实现监听器还有印象的朋友应该可以看出来在registerNetworkCallback()方法中直接使用匿名内部类也完全可以。 这一版在初步测试里没发现什么问题，于是突发奇想想做个拓展，没有网络时在界面上显示一个红色背景的文本框title，有网络时文本框自动消失。于是抱着试试看的心态写了第二版：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; private TextView title; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); connMgr.registerNetworkCallback(networkRequest, networkCallback); &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); Toast.makeText(getBaseContext(), \"网络正常\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); Toast.makeText(getBaseContext(), \"网络已断开\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.VISIBLE); &#125; &#125;&#125; 结果收到了android.view.ViewRootImpl$CalledFromWrongThreadException，提示”Only the original thread that created a view hierarchy can touch its views.”，只有原始的创建了View结构的线程才能访问它的View。并且还提示错误来源于ConnectivityThread。经过又一番查询得知，Android应用的主线程控制UI的绘制，又称为UI线程，如果从其他线程访问UI将会遇到这个异常。那为什么更改title的可见性不是从主线程发出的呢？查询资料后发现，ConnectivityManager中封装了ConnectivityService，而ConnectivityService中会用到ConnectivityThread，所以是自动转到主线程之外了。 看来只能新建一个线程进行UI更新的相关操作了。这里使用了Handler来处理其他线程发给主线程更新UI的相关信息。这是第三版，其中把向主线程发送信息做成了方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; private TextView title; private MyHandler handler; private final int CONN_AVAILABLE = 1; private final int CONN_UNAVAILABLE = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); handler = new MyHandler(); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); MyThread thread = new MyThread(); new Thread(thread).start(); &#125; private void sendConnInfo(int info)&#123; Message message = new Message(); Bundle bundle = new Bundle(); bundle.putInt(\"conn\", info); message.setData(bundle); handler.sendMessage(message);//给handler发送连接可用的信息 &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); sendConnInfo(CONN_AVAILABLE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; class MyThread implements Runnable&#123; @Override public void run() &#123; connMgr.registerNetworkCallback(networkRequest, networkCallback); if (connMgr.getActiveNetworkInfo()==null)&#123; sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Bundle data = msg.getData(); int netConnectivity = data.getInt(\"conn\"); switch (netConnectivity)&#123; case CONN_UNAVAILABLE: Toast.makeText(getBaseContext(), \"好像没有网络了……\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.VISIBLE); break; case CONN_AVAILABLE: Toast.makeText(getBaseContext(), \"网络已恢复\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); break; default: break; &#125; &#125; &#125;&#125; 这一版解决了android.view.ViewRootImpl$CalledFromWrongThreadException，但是在更进一步的测试中发现了之前没发现的一个问题：开启了开发者模式中“始终保持数据网络”选项（下称“该选项”）时，在数据开启的状态下，开启WiFi时会出现最后结果为没有网络的情况。 仔细查看了官方文档后发现，onAvailable()方法是在框架连接了新的网络时调用： Called when the framework connects and has declared a new network ready for use. 而onLost()方法则是在框架失去某个网络连接时调用： Called when the framework has a hard loss of the network or when the graceful failure ends. 于是又在onLost()方法中加上了NetworkCapabilities.hasTransport()方法用于检测当前网络的类型。我们都知道，一般情况下，当开启数据的同时开启WiFi，系统会自动切换至WiFi，而经过多次实际检测，发现在开启该选项时，这个过程是先连接至WiFi（调用onAvailable()方法），大概过30秒左右再断开数据（调用onLost()方法），所以最后返回的结果是网络断开。 NetworkCapabilities.hasTransport()方法也是官方文档)中建议用于替代旧的获取当前网络类型方法NetworkInfo.getType()的方法，在实际使用中，可以发现新方法获取的信息确实比旧方法多，包括是否计费、是否使用VPN等均可以检测到。 所以在onLost()方法中还得判断一下是不是完全没有网络了，这一点可以用能否获取到NetCapabilities或NetInfo实例来判断。第4版代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity &#123; private ConnectivityManager connMgr; private TextView title; private MyHandler handler; private final int CONN_AVAILABLE = 1; private final int CONN_UNAVAILABLE = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); handler = new MyHandler(); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); MyThread thread = new MyThread();//新建Runnable实例 new Thread(thread).start();//启动新线程 &#125; //给handler发送连接可用的信息 private void sendConnInfo(int info)&#123; Message message = new Message(); Bundle bundle = new Bundle(); bundle.putInt(\"conn\", info); message.setData(bundle); handler.sendMessage(message); &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); sendConnInfo(CONN_AVAILABLE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); //此处遇到问题，开启开发者选项“始终开启移动数据网络”时，在开启数据时打开wifi，最终呈现是网络断开，但是能用NetworkCapabilities检测到wifi //查看文档发现onLost()方法是在有`network`断开而并非**所有`network`都断开**时，即有任意网络连接断开时即触发。 //onAvailable()方法是在有**新的**`network`可用时触发。 //经检测当wifi和移动网络同时连接时，先连接wifi，触发onAvailable()方法，但移动网络要过30s左右才断开，所以会触发onLost()方法。 //另有开启开发者选项“始终开启移动数据网络”时，数据WiFi双开时关闭WiFi后先调用`onAvailable()`方法后调用`onLost()`方法，且`NetworkCapabilities`为null的情况。 //结果发现出现此Bug的原因是关闭WiFi时刚好是之前讲的连接了WiFi后和断开移动网络前，所以只会调用`onLost()`方法。 //此处整理一下开启“始终开启移动数据网络”与否的双开网络变化情况。 //开启时：开着数据开WiFi时：先连接WiFi（但测试是数据），过约30s后断开数据。 双开关闭WiFi时：依据关WiFi的时机而定，在前述的30s内会无网络，30s之后马上切换至数据。 //关闭时：开着数据开WiFi时：先连接WiFi，再马上关闭数据。 双开关闭WiFi时：先关闭WiFi，再连接数据。 if (connMgr.getNetworkCapabilities(connMgr.getActiveNetwork()) == null) sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; class MyThread implements Runnable&#123; @Override public void run() &#123; connMgr.registerNetworkCallback(new NetworkRequest.Builder().build(), new NetworkCallbackImped()); //初始化时判断有无网络 if (connMgr.getActiveNetworkInfo()==null)&#123; sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Bundle data = msg.getData(); int netConnectivity = data.getInt(\"conn\"); switch (netConnectivity)&#123; case CONN_UNAVAILABLE: Toast.makeText(getBaseContext(), \"好像没有网络了……\", Toast.LENGTH_SHORT).show(); title.setText(\"好像没有网络了……\"); title.setVisibility(View.VISIBLE); break; case CONN_AVAILABLE: Toast.makeText(getBaseContext(), \"网络已恢复\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); break; default: break; &#125; &#125; &#125;&#125; 其实最后还是有一个Bug没有解决，那就是开启“始终保持移动网络连接”时，在上述的30s内（即开启数据后开启WiFi时系统连接WiFi但未关闭数据时）关闭WiFi时，最后会检测不到网络（表现为最后调用的是onLost()且NetworkCapabilities和NetInfo均为null）。个人猜测可能是NetworkCallback的方法回调与上述两实例的获取之间存在时间差，也有可能是个体差异（测试机型为一加6，系统版本为ONEPLUS A6000_22_180810及其上一版）。 在进一步用Nubia Z11（Android 6.0.1）测试时，情况又有所变化。在未开启“始终保持移动网络连接”选项时，会出现类似一加6开启该选项的情况（即30s延迟）。但开启该选项后，双开后断开WiFi始终检测不到网络。 如果有朋友知晓原因，恳请不吝解惑！QQ: 504869112","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"实战","slug":"实战","permalink":"http://zyfAndroid.com/tags/实战/"},{"name":"网络","slug":"网络","permalink":"http://zyfAndroid.com/tags/网络/"},{"name":"ConnectivityManager","slug":"ConnectivityManager","permalink":"http://zyfAndroid.com/tags/ConnectivityManager/"},{"name":"NetworkCallback","slug":"NetworkCallback","permalink":"http://zyfAndroid.com/tags/NetworkCallback/"},{"name":"线程","slug":"线程","permalink":"http://zyfAndroid.com/tags/线程/"},{"name":"Handler","slug":"Handler","permalink":"http://zyfAndroid.com/tags/Handler/"}]},{"title":"Android第六课——活动的生命周期","slug":"Android第六课——活动的生命周期","date":"2018-08-14T01:52:21.000Z","updated":"2018-08-14T02:10:06.256Z","comments":true,"path":"2018/08/14/Android第六课——活动的生命周期/","link":"","permalink":"http://zyfAndroid.com/2018/08/14/Android第六课——活动的生命周期/","excerpt":"","text":"活动的生命周期返回栈Android使用任务(Task)来管理活动。一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack)。启动新活动时，该活动入栈，居于栈顶。按下Back键或调用finish()方法销毁活动时，处于栈顶的活动出栈，前一个入栈的活动居于栈顶。系统总是显示处于栈顶的活动给用户。 活动状态每个活动在生命周期内最多有4种状态。 运行状态：活动位于返回栈栈顶时。系统最不愿意回收这种状态的活动。 暂停状态：活动不再处于栈顶但依然可见时（比如处在对话框活动之下的活动）。系统也不愿意回收此类活动。 停止状态：活动不在栈顶且完全不可见时。系统仍会为其保存相应的状态和成员变量，但当需要内存时有可能会被系统回收。 销毁状态：活动从返回栈移除后。系统最倾向于回收此类活动。 活动生存期Activity类中提供了7个回调方法，可将活动的生命周期分成3个生存期。 完整生存期：在创建新活动时调用的onCreate()方法和销毁活动时调用的onDestory()方法之间的周期。 可见生存期：活动在由不可见变为可见时调用onStart()方法和在完全不可见时调用onStop()方法之间的周期。 前台生存期：活动在处于运行状态，准备好与用户交互时调用onResume()方法与活动被挂起，系统准备去启动或恢复另一活动时调用onPause()方法之间的周期。onPause()方法中通常释放一些消耗CPU的资源，保存一些关键数据，但方法执行速度一定要快。 onRestart()方法负责把活动从停止状态恢复为运行状态，即从onStop()后的活动执行，之后会执行onStart()方法。 在活动被回收前保存临时数据 Activity类中提供了一个onSaveInstanceState()回调方法，该方法可以保证在活动被回收之前一定会被调用。 该方法会携带一个Bundle类型的参数。Bundle提供了一系列方法用于保存数据，比如用putString()方法保存字符串，用putInt()方法保存整形数据，以此类推。 每个保存方法需要两个参数：键，相当于成员名，变量名，用于之后从Bundle中取值；第二个参数是要保存的值。 只需在onCreate()方法中传入之前保存的Bundle就可以在方法中取出之前保存的值。 可以把Bundle存放在Intent里实现跨活动传递数据。 活动的启动模式 主要是决定返回栈与返回栈中活动实例个数的设置，一共有四种，分别是standard,singleTop,singleTask,singleInstance，可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性选择启动模式。 standard模式下，每当启动一个新的活动，系统就会创建一个新的实例，它会入栈且处于栈顶。换句话说，standard模式对活动在返回栈中的唯一性不做任何保证。 用this.toString()方法可以把当前活动实例转换成字符串。 singleTop模式下，在启动活动时如果发现返回栈栈顶已经是该活动的一个实例则不再启动新活动。 singleTask模式下，在启动活动时如果发现返回栈中存在该活动实例则将其上所有活动都出栈使其置顶。 实际上我们在使用时发现，对于设置了”singleTask”启动模式的Activity，它在启动的时候，会先检测系统中属性值affinity等于它的属性值taskAffinity的task是否存在；如果存在这样的task，它就会在这个task中启动，否则就开启一个新的task。而taskAffinity默认情况下是应用的包名，即默认时并不会新建一个task。 因此，如果我们想要设置了”singleTask”启动模式的Activity在新的task中启动，就要为它设置一个独立的taskAffinity属性值。下面的代码中，应用程序的包名是com.fred.testactivity，我们将BActivity的启动模式设置成singleTask, 同时设置其taskAffinity属性为com.fred.testactivity.BActivity 。当BActivity启动时，会发现多了一个task 。代码如下：123456 &lt;activity android:name=\".BActivity\" android:label=\"@string/title_activity_b\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.fred.testactivity.BActivity\"&gt;&lt;/activity&gt; ==注== 此时该活动实例将会从停止/暂停状态恢复至运行状态，注意与活动生命周期结合理解。 singleInstance模式下，在整个系统中都只存在一个实例，因为系统会为该活动实例创建一个单独的返回栈。 使用getTaskId()可以获取当前任务ID的字符串。 关于活动的技巧知道当前界面对应的活动 用一个普通Java类作为AppCompatAvtivity的父类(e.g.BaseActivity)，再让所有活动都继承该类，在该类中重写onCreate()方法，打印一条以getClass().getSimpleName()作为内容的日志即可。getSimpleName()为获取当前类的简写名。 随时随地退出程序 新建一个Activity列表类，在其中写添加、去除Activity项以及借助finish()方法来结束列表中所有Activity的静态方法（e.g.finishAll()，静态是为了无需创建列表的实例） 在之前的BaseActivity中重写onCreate()和onDestroy()方法，加入在列表中添加、删除活动的方法调用。 接下来只需在需要结束所有活动的地方调用finishAll()方法即可。 也可以在finishAll()方法后加上杀掉当前进程的代码保证程序完全退出123android.os.Process.killProcess(android.os.Process.myPid());//killProcess()方法只能杀掉自己//通过myPid()方法获取当前进程的id 启动活动的更好方法 在活动中自己写一个actionStart()方法，在方法中通过传入的参数完成构建启动活动的Intent和调用startActivity()。 这样的好处在于可以清楚地看到需要传递的数据有哪些，而且在需要启动活动时只需调用该方法，无需再自己创建Intent等。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第六课","slug":"第六课","permalink":"http://zyfAndroid.com/tags/第六课/"},{"name":"Activity","slug":"Activity","permalink":"http://zyfAndroid.com/tags/Activity/"},{"name":"生命周期","slug":"生命周期","permalink":"http://zyfAndroid.com/tags/生命周期/"}]},{"title":"Android第五课——进阶组件之Intent初探","slug":"Android第第第五课——进阶组件之Intent初探","date":"2018-08-13T02:58:46.000Z","updated":"2018-08-13T04:59:42.849Z","comments":true,"path":"2018/08/13/Android第第第五课——进阶组件之Intent初探/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第第第五课——进阶组件之Intent初探/","excerpt":"","text":"Intent Intent 会在运行时将各个组件相互绑定（您可以将 Intent 视为从其他组件请求操作的信使），无论组件属于您的应用还是其他应用。 Intent是Android程序中各组件之间交互的重要方式，不仅可指明当前组件想要的动作，还能在不同组件间传递数据。 Intent包含的部分：组件名称，操作，数据，类别，Extra，标志 显式Intent 显式Intent指定明确的上下文和要转到的活动的class对象12345678Intent(Context packageContext, Class&lt;&gt; cls)//第二个参数指定想要启动的目标活动button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125; &#125;); 隐式Intent 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 隐式Intent不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。创建隐式Intent时,Android系统通过将Intent的内容与在设备上其他应用的清单文件中声明的Intent过滤器进行比较，从而找到要启动的相应组件。如果Intent与Intent过滤器匹配，则系统将启动该组件，并向其传递Intent对象。如果多个Intent过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。 Intent过滤器是应用清单文件中的一个表达式，它指定该组件要接收的Intent类型。例如，通过为Activity声明Intent过滤器，您可以使其他应用能够直接使用某一特定类型的Intent启动Activity。同样，如果您没有为Activity声明任何Intent过滤器，则Activity只能通过显式Intent启动。只有Intent过滤器的action标签与catogory标签同时与Intent中指定的action和category匹配时活动才能响应该Intent。12345678910button1.setOnClickListener(new View.OnClickListener()&#123; @override public void onClick(View v)&#123; Intent intent = new Intent(\"com.example.activitytest.ACTION_START\"); //此处使用Intent的另一个构造函数，传入action字符串即可。 startActivity(intent); //\"android.intent.category.DEFAULT\"是一种默认的category，调用startActivity()方法时会自动将其添加到Intent中。 //或intent.addCategory(\"categoryName\");来添加category &#125;&#125;); 还可以利用隐式Intent启动其他应用程序内的活动，比如分享到其他App，打开网页等操作。 12345678910button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); //这是Android系统内置的一个动作，其常量值为android.intent.action.VIEW intent.setData(Uri.parse(\"http://www.baidu.com\")); //通过Uri.parse()方法将网址字符串解析成Uri对象，使用setData()方法把URI赋给Intent。（Intent的Data使用URI来表示） startActivity(intent); &#125; &#125;); 在AndroidManifest.xml文件中，可以为活动的Intent过滤器指定额外的&lt;data&gt;标签限定活动能响应的URI类型。只有&lt;data&gt;标签中指定的内容和Intent中携带的Data完全 一致时，当前活动才能够响应该Intent。以下是常用的标签内容： android:scheme。用于指定数据的协议部分，如http，geo(地理位置)，tel(拨打电话)等。 android:host。用于指定数据的主机名部分，如www.baidu.com。 android:port。用于指定数据的端口部分，一般紧随在主机名之后。 android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 可以使用Intent在启动活动的同时传递数据。 把需要传递的数据用putExtra()方法存放在Extra中 在另一个活动中用getIntent()方法取得传来的Intent 用getStringExtra()方法取回数据（其他类型类似） 也可以使用Intent给上一个活动返回数据。开发文档中有一个startActivityForResult()方法用于启动活动并向上一个活动返回数据。 给它传递一个启动活动用的Intent和一个唯一的requestCode参数 在另一个活动中用另一个Intent的Extra携带要返回的信息 用setResult()方法设置传回Intent和结果（RESULT_OK或RESULT_CANCELED） 用finish()方法结束当前活动并传回Intent 返回到上一个活动后会回调onActivityResult()方法，重写该方法添加从中得到返回的数据的逻辑 注意“返回到上一个活动时”包含所有返回的情况，如按Back键等，在按Back键返回的情况下需要重写onBackPressed()方法来执行setResult()方法。（此时super.onBackPressed()要写在最后） 更多Intent的例子会在之后的广播中遇到。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第五课","slug":"第五课","permalink":"http://zyfAndroid.com/tags/第五课/"},{"name":"Intent","slug":"Intent","permalink":"http://zyfAndroid.com/tags/Intent/"}]},{"title":"Android第四课——进阶组件之Toast与菜单","slug":"Android第四课——进阶组件之Toast与菜单","date":"2018-08-13T02:54:08.000Z","updated":"2018-08-13T02:56:45.845Z","comments":true,"path":"2018/08/13/Android第四课——进阶组件之Toast与菜单/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第四课——进阶组件之Toast与菜单/","excerpt":"","text":"进阶组件Toast12345678910//Toast是android.widget包内的类//makeText是Toast的静态方法，返回一个按照参数生成的ToastToast toast = Toast.makeText(context, text, duration);toast.show();//context相当于一个场景、情景，application/service/activity都是它的子类//text是要显示的文本//duration是持续时间，有Toast.LENGTH_SHORT和Toast.LENGTH_LONG两个内置常量可选Toast.makeText(FirstActivity.this, \"text\", Toast.LENGTH_SHORT).show();//先执行makeText()方法，其返回的Toast对象再执行show()方法 需要为Toast设置触发条件。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); //用findViewById()方法找到button1(view类)，再转换成button类 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this, \"You clicked Button 1\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 改变Toast的位置 123456Toast toast = Toast.makeText(context, text, duration);toast.setGravity(Gravity.TOP|Gravity.LEFT, 0, 0);toast.show();//让Toast出现在容器的左上角//Gravity是Object的子类，有TOP/BOTTLE/LEFT/RIGHT/CENTER等常用int常量//第二、第三个参量是向右、向下移动Toast的偏移量 菜单菜单资源 需要在res/menu下建立菜单资源文件12345678&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/add_item\" android:title=\"Add\"/&gt; &lt;item android:id=\"@+id/remove_item\" android:title=\"Remove\"/&gt; &lt;/menu&gt; 部署菜单 重写onCreateOptionsMenu()方法创建菜单 123456public boolean onCreateOptionsMenu(Menu menu) &#123; //传入一个menu变量 getMenuInflater().inflate(R.menu.main, menu); //先调用getMenuInflater()方法得到MenuInflater对象 //再调用它的inflate()方法创建menu实例 return true;//方法中创建的菜单可见&#125; 重写onOptionsItemSelected()方法定义菜单响应事件 123456789101112public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123;//调用getItemId()方法得到被点击的菜单项ID case R.id.add_item: Toast.makeText(this, \"You clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, \"You clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第四课","slug":"第四课","permalink":"http://zyfAndroid.com/tags/第四课/"},{"name":"Toast","slug":"Toast","permalink":"http://zyfAndroid.com/tags/Toast/"},{"name":"菜单","slug":"菜单","permalink":"http://zyfAndroid.com/tags/菜单/"}]},{"title":"Android第三课——测试与调试","slug":"Android第三课——日志工具Logcat的使用","date":"2018-08-12T05:27:37.000Z","updated":"2018-08-12T05:28:45.774Z","comments":true,"path":"2018/08/12/Android第三课——日志工具Logcat的使用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第三课——日志工具Logcat的使用/","excerpt":"","text":"测试与调试log类与logcat工具分类 Log.v()，对应verbose级别，最低的日志级别 Log.d()，对应debug级别，运行时会被去掉 Log.i()，对应info级别 Log.w()，对应warn级别 Log.e()，对应error级别用法 传入两个字符串参数 tag，一般传入当前的类名即可，用于对打印信息进行过滤 msg，想要打印的具体内容 输入logX按TAB即可补全对应的方法。 在onCreate()方法外输入logt按TAB即可生成当前类名的tag常量。 可以在logcat中用关键字进行进一步过滤日志，关键字支持正则表达式。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第三课","slug":"第三课","permalink":"http://zyfAndroid.com/tags/第三课/"},{"name":"日志","slug":"日志","permalink":"http://zyfAndroid.com/tags/日志/"},{"name":"logcat","slug":"logcat","permalink":"http://zyfAndroid.com/tags/logcat/"}]},{"title":"Android第二课——构建简单的应用","slug":"Android第二课——构建简单的应用","date":"2018-08-12T05:16:22.000Z","updated":"2018-08-12T05:18:38.234Z","comments":true,"path":"2018/08/12/Android第二课——构建简单的应用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第二课——构建简单的应用/","excerpt":"","text":"编写应用一个最简单的app主代码12345678public class HelloWorldActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.hello_world_layout); //R类是自动生成的，包含所有res目录下资源的id &#125;&#125; AppCompatActivity是一种向下兼容的Activity,是Activity的子类。Activity是Android系统提供的一个活动基类，所有活动必须继承它或它的子类才拥有活动的特性。 onCreate()方法是创建活动时必定会执行的方法。 setContentView()方法为当前活动引入布局。Android程序的设计讲究逻辑与视图分离，因此常在布局文件中编写界面，然后在活动中引入。 使用finish()方法销毁活动。 layout文件123456789101112131415161718192021222324&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/hello_world_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.example.helloworld.HelloWorldActivity\"&gt; &lt;Button android:id=\"@+id/button_1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button 1\" /&gt;&lt;!--引用id用@id/name语法，定义id用@+id/name语法-&gt;&lt;!--TextView为文本--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; &lt;/RelativeLayout&gt; 资源——字符串123&lt;resources&gt; &lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt; &lt;/resources&gt; 引用资源的方式 代码中：通过R.string.app_name引用该字符串。 XML中：通过@string/app_name引用该字符串。\\其中string部分可替换成需要引用的资源类型，如layout,drawable等。例见AndroidManifest.xml文件。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第二课","slug":"第二课","permalink":"http://zyfAndroid.com/tags/第二课/"},{"name":"资源","slug":"资源","permalink":"http://zyfAndroid.com/tags/资源/"}]},{"title":"Android第一课——初识Android","slug":"undefined-2018-08-12","date":"2018-08-12T04:24:28.000Z","updated":"2018-08-12T04:31:22.678Z","comments":true,"path":"2018/08/12/undefined-2018-08-12/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/undefined-2018-08-12/","excerpt":"","text":"Android四大组件Activity活动 包含应用所有看得见的东西Service服务 无法看到，在后台运行，退出应用仍可继续运行Broadcast Receiver广播接收器 允许应用接收来自各处的消息，如电话、短信等。应用也可发出自己的广播消息。Content Provider内容提供器 程序间共享数据的方法 Android工程的结构 AndroidManifest.xml12345678910111213141516171819202122&lt;!--注意application标签要写在所有其他标签之后--&gt;&lt;activity android:name=\".HelloWorldActivity\" android:label=\"Title\"&gt;&lt;!--程序包名可省略--&gt; &lt;intent-filter&gt; &lt;!--在intent-fliter中指示该应用可以处理的intent类型--&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;!--action和category两行表示该活动为主活动--&gt; &lt;!--可选用data标签指定当前活动能响应的数据类型--&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; ... &lt;/application&gt; build.gradle~\\build.gradle12345678910111213buildscript &#123; repositories &#123; jcenter()//jcenter是一个代码托管仓库，有这一行就可以引用上面的开源项目 &#125; dependencies &#123; classpath 'com.android.tools.build: gradle:2.2.0' &#125; &#125; allprojects &#123; repositories &#123; jcenter() &#125; &#125; ~\\app\\src\\build.gradle1234567891011121314151617181920212223242526272829303132apply plugin:'com.android.application' //表示这是应用程序模块//com.android.library表示库模块android &#123;//android闭包 compileSdkVersion 24 buildToolsVersion \"24.0.2\" defaultConfig &#123; applicationId \"com.example.helloworld\" //包名 minSdkVersion 15 //最低兼容版本 targetSdkVersion 24 //做过充分测试的版本 versionCode 1//版本号 versionName \"1.0\"//版本名 &#125; buildTypes &#123; release &#123; minifyEnabled false//是否对项目代码混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; &#125; dependencies &#123; compile fileTree(dir:'libs', include:['*.jar']) //本地依赖声明 compile 'com.android.support:appcompat-v7:24.2.1' //远程依赖库 //com~support是域名 //app~v7是组名 //24.2.1是版本号 //库依赖：compile project(':libraryxxx') testCompile 'junit:junit:4.12'//测试用例库&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"工程","slug":"工程","permalink":"http://zyfAndroid.com/tags/工程/"},{"name":"结构","slug":"结构","permalink":"http://zyfAndroid.com/tags/结构/"},{"name":"第一课","slug":"第一课","permalink":"http://zyfAndroid.com/tags/第一课/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-12T02:24:45.393Z","updated":"2018-08-12T05:31:19.240Z","comments":true,"path":"2018/08/12/hello-world/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/hello-world/","excerpt":"","text":"这里是我的Android开发学习笔记。我使用Android Studio + Java进行开发，以郭霖的《第一行代码》为主要参考资料，辅以Android官方文档及网上其他资料。 由于本人纯小白，也会在此发表一些Java学习笔记。因为本人处在不断学习的阶段，之前发表的文章也可能会更新内容。 本博客使用Hexo 搭建。","categories":[],"tags":[]}]}