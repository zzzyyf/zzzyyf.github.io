{"meta":{"title":"从0.1开始学Android","subtitle":"zyf的Android学习笔记","description":"Android Tutorial","author":"Winfrid Zhao","url":"http://zyfAndroid.com"},"pages":[],"posts":[{"title":"算法（一）——快速排序","slug":"算法——快速排序","date":"2019-08-27T09:20:00.000Z","updated":"2019-08-27T11:21:57.080Z","comments":true,"path":"2019/08/27/算法——快速排序/","link":"","permalink":"http://zyfAndroid.com/2019/08/27/算法——快速排序/","excerpt":"","text":"前言这是我的算法整理的第一篇，其实之前已经有在根据《算法图解》进行整理了，但是像二分查找之类的都还算简单，直到最近复习到快速排序，虽然用分治角度重新认识了这个算法，但是感觉细节部分还是有很多讲究，索性写一篇博客整理一下。 算法概述 快速排序的时间复杂度受枢轴选择的影响。 最糟时间复杂度情况为：每次选择的枢轴均为子列表的最值，即每次分解的3部分中有一部分是空表，这样时间复杂度为O(n^2^)（n+n-1+…+1）。 平均时间复杂度为O(nlog n)。 虽然近乎原地，但递归需要栈的支持，最糟空间复杂度的情况下为O(n)，平均空间复杂度为O(log n)。 从分治角度来看分治即分而治之（Divide and Conquer），简单来说就是把规模较大的问题简化为规模较小的问题进行解决。分治问题的两个要素为：寻找使问题得到解决的基线条件（尽可能简单），以及分解问题或缩小问题规模以达到基线条件的方法。虽然可能并不是很常用到分治这个词，但其实这是一个很常用的思考方式。拿快速排序来说，其基线条件就是表中只含有小于2个元素，而分解问题的方法就是递归地把表分解为3个部分：枢轴pivot，比枢轴小的部分和比枢轴大的部分。 其实到这里以后，用一些便于在线性表中添加元素和合并线性表的语言其实已经可以便捷地实现快排了。核心思想就是：递归地把表分解为3个部分，直到每个表都只有0个或1个元素，然后再把表合并起来。此处给出Java List版的快排代码（笔者对Java不甚了解，现学现卖，若有啰嗦甚至错误之处烦请赐教）：12345678910111213141516171819202122232425262728/** * This method uses simple quick sort algorithm to sort a List. * That is, create 2 lists in every sort, and at the end of recursion, merge 2 lists together. * @param list */public List&lt;Integer&gt; quickSort(List&lt;Integer&gt; list)&#123; int p = 0; // choose a pivot // partition List&lt;Integer&gt; listBelow = new ArrayList&lt;&gt;(); List&lt;Integer&gt; listAbove = new ArrayList&lt;&gt;(); for (Integer elem:list) &#123; if(elem&lt;=list.get(p)) listBelow.add(elem); // elems equal to pivot should either goto listBelow or listAbove else listAbove.add(elem); &#125; listBelow.remove(0); // remove pivot // recursion if(listBelow.size()&gt;1) // base condition listBelow = quickSort(listBelow); // sort listBelow if(listAbove.size()&gt;1) listAbove = quickSort(listAbove); // sort ListAbove // merge listBelow.add(list.get(0)); // add pivot listBelow.addAll(listAbove); return listBelow;&#125; 但是如果是顺序存储的线性表，如数组就没那么简单了，因为新建数组、合并数组、向数组中添加元素都比较复杂。再加上对表的分解、合并操作其实比较繁琐，时间上不高效。 常见实现更常用的排序方法需要借助在线性表头尾的两个指针。这种排序方法有两种具体实现： 在线性表头和尾设置两个指针i和j 指定一个枢轴pivot 从i开始向表尾寻找小于（或等于）枢轴的项 从j开始向表头寻找大于枢轴的项 若找到则交换i、j指向的项，从j开始向表头寻找大于（或等于）枢轴的项 若找到则把j指向的项赋给i指向的项，从i开始项表尾寻找小于枢轴的项 以此类推直到i&gt;j为止 以此类推直到i=j为止 暂且把1称为快排的交换方式实现，2称为快排的覆盖方式实现。12345678910111213141516171819202122232425262728293031void quickSort(int list[], int i, int j)&#123; // choose a pivot int p=i; // choose the first elem **in the current part** as pivot int elem = list[p]; int temp; // used in swapping method int start = i; int end = j; // partition if(j==i) return; // in swapping method, the condition below is j&gt;=i while(j&gt;i)&#123; for(;list[j]&gt;=elem &amp;&amp; i&lt;j;j--); if(i!=j) // here covered pivot first, finally place pivot to where i&amp;j meet. // this realization should be based on that **j replace pivot at first**. // in swapping method, swap list[i] and list[j]. list[i] = list[j]; else break; for(;list[i]&lt;=elem &amp;&amp; i&lt;j;i++); if(i!=j) // in swapping method, swap list[i] and list[j]. list[j] = list[i]; &#125; list[i] = elem; // in swapping method there's no this step. // recursion if(i&gt;start+1) quickSort(list, start, i-1); // if parameters here and following are both i rather than i-1 &amp; i+1, recursion may not end. if(i&lt;end-1) quickSort(list, i+1, end);&#125; 有几个需要注意的点： 这种实现需要处理数组的一部分，而不是仅仅处理整个数组，所以需要注意各处的具体实现不要写错了。 递归时需要跳过枢轴项，不然可能会死循环。 覆盖方法要求从j开始，第一次交换覆盖掉枢轴项，因此需要保存枢轴的值。 可以看出，覆盖方式要比交换方式稍省时一些。空间复杂度上二者差不多。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://zyfAndroid.com/tags/算法/"},{"name":"快速排序","slug":"快速排序","permalink":"http://zyfAndroid.com/tags/快速排序/"}]},{"title":"C语言基础填坑（一）——多维数组","slug":"C语言基础填坑（一）——多维数组","date":"2019-04-13T03:38:10.000Z","updated":"2019-04-13T15:21:14.949Z","comments":true,"path":"2019/04/13/C语言基础填坑（一）——多维数组/","link":"","permalink":"http://zyfAndroid.com/2019/04/13/C语言基础填坑（一）——多维数组/","excerpt":"","text":"背景舍友今天突然问我怎么把数组传入函数，我一开始心想这不是小儿科了吗，就说传指针。不过这时候我已经隐约感到有点知识空缺了，因为一时对直接传值传入数组好像没有概念了。然后舍友又遇到问题了，我一看才知道是要传入多维数组。我又想，多维和一维的存储是类似的啊，多维的存储仍然是线性的，只是需要切分成几段而已，所以应该也不难。但是上来我就蒙了：12int a[3][3];int *p = a; 按照我的逻辑，反正都是int的指针，也就数组名是常量指针，但也可以被赋给其他指针吧？但Build之后…… E:\\My Codes\\test2\\main.c|284|warning: initialization of ‘int ‘ from incompatible pointer type ‘int ()[3]’ [-Wincompatible-pointer-types]| 舍友的XCode上直接是Error。那看来我的想法是错的……连忙翻出《C Primer Plus》（第6版中文版），开始补课！ 多维数组此处以二维数组为例。1int zippo[4][2]; 我们可以把zippo[i]理解为（子）数组，其既是zippo的元素也是int的数组。因为它是数组，所以它可以作为数组名使用，即zippo[i]指向zippo[i][0]。解引用*和数组引用[]具有相同的功能，既然zippo[i][j]才是int元素的话，那么zippo显然就是一个二重指针了。所以我之前的想法是错误的。而且指针的类型比元素之间的更加严格，即使仅仅是维数不同也不行。我觉得应该是因为数组指针还记录了每个元素的长度，如果可以“降维”的话长度信息就彻底丢失了。所以要想达到传入首址的目的，需要写成：123int *p = a[0];//误：不要写一维数组顺手了写成下面的形式int *p = &amp;a[0]; //这是取了子数组的首址的地址，即int ** 若多维数组传参是只传入了首址的话，只需要知道各维的长度就可以用多重引用访问数组元素了。1p[j+3*i]=x; 我们也可以用更简单直观的方式，即与定义相同的方式p[i][j]访问多维数组。可是如此一来，需要知道下一层一直到最底层子数组的长度。所以只传首址好像不太够？当然办法也是有的，让我们往下看。 数组作参数首先确认一点，数组是无法直接传值的，因为传值效率不如传址效率高。另外，可以使用const关键字使函数把传入的数组视作常量，保护数据。此时const写在类型之前。 一维数组简单回忆一下，一维数组传参只能传入数组元素类型和首地址，数组长度需要另行传入。另一个知识点是，在函数签名中可以用array[]代替*array表示指针参数，但只能在函数签名中这样使用。 多维数组除了只传入首地址外，要想简单直观地使用多维数组，需要传入首址和所有子数组的长度。传入的格式也很简单：1234567void func(int a[][3])&#123;&#125;// 3即为子数组的长度void func2(int a[][3][4])&#123;&#125;// 首个方括号即为 array[]，表示这是个指针// 首个方括号中为了可读性也可写上值，但会被忽略。// 第二个起所有方括号都必须写上长度。void func3(int (*a)[3][4])&#123;&#125; //等价形式 需要注意的是，虽然看起来像是传值，但确实是传址引用，数据的值确实会被改变，这一点有点反直觉。 参考：《C Primer Plus（第6版）中文版》，第10章","categories":[],"tags":[{"name":"C Language","slug":"C-Language","permalink":"http://zyfAndroid.com/tags/C-Language/"},{"name":"多维数组","slug":"多维数组","permalink":"http://zyfAndroid.com/tags/多维数组/"},{"name":"基础","slug":"基础","permalink":"http://zyfAndroid.com/tags/基础/"}]},{"title":"Java I/O简要笔记（一）——基础部分","slug":"JavaIO","date":"2018-09-21T14:09:53.000Z","updated":"2018-09-28T16:09:52.792Z","comments":true,"path":"2018/09/21/JavaIO/","link":"","permalink":"http://zyfAndroid.com/2018/09/21/JavaIO/","excerpt":"","text":"因为以Android开发为主要目的，本篇博客的主要参考资料为Android Developers的文档。 Java I/O基础Java I/O主要包括如下几个层次，包含三个部分： 流式部分――I/O的主体部分； 非流式部分――主要包含一些辅助流式部分的类，如：File类、RandomAccessFile类和FileDescriptor等类； 其他类–文件读取部分的与安全相关的类，如：SerializablePermission类，以及与本地操作系统相关的文件系统的类，如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。流 Java把数据传输这件事称为流。 Java 中的 I/O流类分为输入和输出部分。通过继承InputStream或Reader的类都有read()方法，它可以读取单个字节或者字节数组。而继承OutputStream或 Writer的类都有write()方法，它可以写入单个字节或者字节数组。一般通过组合多个对象来提供我们期望的功能（装饰器模式）。 Java的IO模型设计非常优秀，它使用Decorator(装饰器)模式，按功能划分Stream，可以动态装配这些Stream，以便获得需要的功能。例如，若需要一个具有缓冲的文件输入流，则应当组合使用FileInputStream和BufferedInputStream。 Java中的InputStream与OutputSream提供基于字节的IO操作。 Java中的Reader与Writer以面向Unicode字符(16位，2个字节)的方式提供I/O功能。字符流的本质是基于字节流I/O时（调用了转换器）查了对应的码表。可以使用InputStreamReader以及OutputStreamWriter适配器将字符流转化为字节流。 ==Tips:==适配器是连接不匹配的二者，让以上两者变匹配的对象。此处的两个适配器要把字符流转化为字节流，所以要在具备基础IO功能的基础上实现最基础的字符流的功能，而恰好Reader和Writer类是最基础的字符流，所以可以通过实现InputStream或OutputStream实现的接口+继承Reader或Writer类来实现转换。 字符流Reader类 Writer类 使用字符输出所用的抽象类，以下是子类必须实现的方法：123456public abstract void write(char[], int, int);//输出给定字符数组中从int起的int个字符public abstract void flush();//用于flush整条流。当本Writer在缓冲区里保存了字符时，立即将保存的字符都写入目的地，并且若目的地也是流，也flush它，由此可知flush()方法会清空整条流上的所有缓冲区//若目的地为文件，则flush方法保证缓冲区中的字符都交给操作系统作写入处理，但不保证字符确实被写入物理存储设备public abstract void close();//关闭本流，关闭前先flush它//对已经关闭的流执行write()或flush()方法会导致抛出IOException OutputStreamWriter 如前文所述是字符流转为字节流的适配器，可以指定编码或编码器，否则使用平台默认编码；未指定编码器时，对于无法映射的Unicode字符组统一使用编码的默认替代字符来替代。 在将字符转为字节时，亦如前文所述，会调用转换器进行字符与字节的转换。而OutputStreamWriter会在向底层输出流写入转换完成的字符前将其存入缓冲区，减少了写入操作频率，提升效率。注意：输入的字符没有缓冲。123public OutputStreamWriter(OutputStream)//可选重载参数：String charsetName, 指定的编码名；Charset csn, 指定的编码；//CharsetEncoder enc, 指定的编码器 ==Tips:== 因为输入OutputStreamWriter的字符没有经过缓冲，为了实现最佳性能，推荐使用时在OutputStreamWriter外包装BufferedWriter。 BufferedWriter 提供适配不同环境的newLine()方法用于换行（并非所有平台均使用\\n进行换行）； 在输出至字符流前会先将字符存入缓冲区，提升效率。12public BufferedWriter(Writer)//可选重载参数：int sz，指定缓冲区大小 FileWriter 写入文件用，使用默认编码和默认字节缓冲区大小（无字符缓冲，可通过包装BufferedWriter来改善性能）。若想改变编码，可在FileOutputStream上使用OutputStreamWriter。123public FileWriter(String fileName)//重载参数：File//可选重载参数：boolean，true时为append模式 ==Tips:== 某些平台只允许一个操作文件的对象(i.e.FileWriter)同时操作同一文件，容易导致抛出IOException。 PrintWriter 输出格式化的文本。可以指定编码。该类中实现了PrintStream类中的所有print*方法以及format()方法。不提供字节输出。 其构造函数包含可选boolean重载参数，值为true时开启自动刷新模式，即在每个print*方法被调用时执行flush()方法。（默认为当输出一个换行符\\n时执行） 除某些构造函数构造的对象外不会抛出IOException。需要手动调用checkError()方法，若返回true则说明在输出至流或在格式化字符串的过程中遇到错误。12345678910public PrintWriter(Writer);//重载参数：OutputStream, File, String fileName.//可选重载参数：boolean，true时为自动刷新模式；String csn，指定的编码。 public PrintWriter append(CharSequence csq)//等价于write(csq.toString()),受缓冲区的限制可能不能输出所有内容 //其他重载没有此限制 //若字符串为null，则输出\"null\"protected void clearError()//初始化checkError()检查的flag","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zyfAndroid.com/tags/Java/"},{"name":"I/O","slug":"I-O","permalink":"http://zyfAndroid.com/tags/I-O/"},{"name":"Writer","slug":"Writer","permalink":"http://zyfAndroid.com/tags/Writer/"}]},{"title":"Android实战记（三）——实现弹出日期选择对话框","slug":"AndroidPractice3","date":"2018-09-04T15:20:08.000Z","updated":"2018-09-04T15:28:21.943Z","comments":true,"path":"2018/09/04/AndroidPractice3/","link":"","permalink":"http://zyfAndroid.com/2018/09/04/AndroidPractice3/","excerpt":"","text":"这次同学提出了一个问题，他没搞懂怎么利用DatePicker实现弹出窗口选择日期的逻辑。于是我看了看官方文档，发现官方对使用Picker专门写了一篇指南。有指南当然是最好了。这篇指南里还有弹出窗口选择时间的例子，跟选择日期的例子很相近，此处不赘述了。 之前已经学习过使用AlertDialog，而此次的DatePickerDialog就继承于AlertDialog，本来感觉会与其有很多相似之处，但其实差距还是挺大的。因为指南中推荐使用DialogFragment来容纳（？原文为host，不知道该怎么翻译）DatePickerDialog或TimePickerDialog，因为 DialogFragment能帮你管理对话框的生命周期，并且允许你在不同的布局配置中显示Picker，如在手机中的基本对话框中或者是在大屏幕里作为布局的一部分嵌入。（说白了就是说Fragment的好处嘛） 然而我看《第一行代码》的时候以为碎片不重要就跳过了。。。没想到现在就要还上一点了。还就还吧~ 配置DialogFragment前面已经说过DatePickerDialog要在DialogFragment中容纳，自然要创建一个DialogFragment。 创建DialogFragment的子Fragment，实现DatePickerDialog.OnDateSetListener接口 覆盖onCreateDialog(Bundle)方法，因为要选择日期，所以要给一个默认值： 使用Calendar.getInstance()获取一个表示当前时间的Calendar对象 调用calendar.get(int)取出对应的年、月、日 return new DatePickerDialog(getActivity(), listener, year, month, day)来创建DatePickerDialog（listener是上面实现的接口的实例，当然是this，也就是这个Dialog。year/month/day是用来设置初始值的） 实现OnDateSetListener接口的onDateSet()方法，此处是时间设定完成后调用，理所当然地要在这里传回设置好的数据。查阅了很多资料，对于Fragment给Activity传递数据都推荐使用实现接口+回调方法来实现，因为DialogFragment提供了onAttach(Context)方法来获取父Activity，不用白不用。这里简单解释一下何为回调，简单地说就是 A持有对B的引用 在A中使用B B中也持有对A的引用 使用完B后在B中回去使用A。 最后一步就称为回调。此例中，父Activity持有对DialogFragment的引用，然后在Activity中创建DialogFragment，获取了用户设置的日期后再回调父Activity将日期返回。 定义传回数据用的接口i.e.SendDate和方法 因为要回调Activity的方法，肯定要持有Activity对象引用，且要在DialogFragment的生命周期结束时将引用释放，免得Activity回收时出现错误。 在onAttach()方法中获取父Activity并判断是否实现SendDate接口 在onDetach()方法中释放对付Activity的引用12345678910111213141516171819202122232425262728293031323334353637public class DatePickerFragment extends DialogFragment implements DatePickerDialog.OnDateSetListener &#123; interface SendDate&#123; public void sendDate(int year, int month, int day); &#125; private SendDate listener; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; // Use the current date as the default date in the picker final Calendar c = Calendar.getInstance(); int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH); int day = c.get(Calendar.DAY_OF_MONTH); // Create a new instance of DatePickerDialog and return it return new DatePickerDialog(getActivity(), this, year, month, day); &#125; public void onDateSet(DatePicker view, int year, int month, int day) &#123; // Do something with the date chosen by the user listener.sendDate(year, month, day); &#125; @Override public void onAttach(Context context) &#123; super.onAttach(context); if (context instanceof SendDate)&#123; listener = (SendDate)context; &#125;else&#123; throw new IllegalArgumentException(\"Activity must implement SendDate\"); &#125; &#125; @Override public void onDetach() &#123; super.onDetach(); listener = null; &#125;&#125; 此处再简单介绍一下DialogFragment的生命周期： onAttach()中传入要attach的Activity实例，使得DialogFragment中可以调用Activity中的方法 onCreate()中可以对对话框的样式进行设置 onCreateDialog()中设置对对话框的监听 onCreateView()中初始化View，并对SavedInstanceState进行解析 onPause()：用户离开片段的第一个信号。通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回） 其他知识点： instanceof运算符用以判断某对象是否为某类的实例。 配置MainActivity 首先需要一个显示读取到的日期的控件，此处选择最简单的TextView。此处不能忘了初始化Text。为了方便测试起见，需要给DatePickerDialog设置一个触发器，这里选择按钮+点击监听。 在点击按钮以后，需要做的事是： 新建一个上面自己写的DialogFragment子类对象； 构建DatePickerDialog并显示； 实现上面写的回调接口。1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends FragmentActivity implements DatePickerFragment.SendDate&#123; private TextView dateText; private Button requireDate; private DatePickerFragment fragment = new DatePickerFragment(); private int year; private int month; private int day; @Override protected void onCreate(Bundle savedInstanceState) &#123; final Calendar calendar = Calendar.getInstance(); year = calendar.get(Calendar.YEAR); month = calendar.get(Calendar.MONTH)+1; day = calendar.get(Calendar.DAY_OF_MONTH); dateText.setText(String.format(\"%d-%d-%d\", year, month, day)); requireDate.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; fragment.show(getSupportFragmentManager(), \"dataPicker\"); &#125; &#125;); &#125; public void setDate(int year, int month, int day)&#123; this.year = year; this.month = month+1; this.day = day; dateText.setText(String.format(\"%d-%d-%d\", this.year, this.month, this.day)); &#125; @Override public void sendDate(int year, int month, int day) &#123; setDate(year, month, day); &#125;&#125; 其他知识点： calendar.get(Calendar.MONTH)方法取得的月份是从0开始的。如果不用一些格式化手段直接用int显示的话，需要+1。（在初始化DatePickerDialog的时候并没有+1，但是月份是正常的，推测是用了其他手段，看了源码没有头绪。。） 如果在自己写的DialogFragment的子类里导入的是android.support.v4.app.DialogFragment的话，在活动中初始化对话框时就要用show(getSupportFragmentManager(), String)方法；如果导入的是android.app.DialogFragment的话，就要用show(getFragmentManager(), String)方法。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"实战","slug":"实战","permalink":"http://zyfAndroid.com/tags/实战/"},{"name":"DialogFragment","slug":"DialogFragment","permalink":"http://zyfAndroid.com/tags/DialogFragment/"},{"name":"DatePickerDialog","slug":"DatePickerDialog","permalink":"http://zyfAndroid.com/tags/DatePickerDialog/"},{"name":"回调","slug":"回调","permalink":"http://zyfAndroid.com/tags/回调/"},{"name":"Fragment Lifecycle","slug":"Fragment-Lifecycle","permalink":"http://zyfAndroid.com/tags/Fragment-Lifecycle/"}]},{"title":"Android实战记（二）——使用本地广播实现强制下线","slug":"androidPractice2","date":"2018-08-23T09:59:01.000Z","updated":"2018-08-23T11:27:50.194Z","comments":true,"path":"2018/08/23/androidPractice2/","link":"","permalink":"http://zyfAndroid.com/2018/08/23/androidPractice2/","excerpt":"","text":"还是《第一行代码》中的例子，这次是广播一章最后的实例，利用广播实现强制下线。 1. 使用TextInputLayout原书中在登录用的LoginActivity里使用的是EditText，但是Android Studio提供的LoginActivity模板中在文本框外嵌套了TextInputLayout。经过查阅资料发现，TextInputLayout能实现很多有意思的功能。先来看看官方文档怎么说（以下本人渣翻译）： （TextInputLayout）是包裹一个EditText（或其子类）的布局，用于在用户进行输入操作，hint隐藏时在文本框上方显示一段悬浮文本。它也支持通过setErrorEnabled(boolean)和setError(CharSequence)方法显示（输入）错误以及通过setCounterEnabled(boolean)显示字符计数器。切换密码可见性也是由其setPasswordVisibilityToggleEnabled(boolean)API及相关（XML）属性支持的。如果启用此功能，当你的EditText被设为显示密码时，会显示一个用于切换密码是否可见的按钮。 看起来确实非常实用，那就试试吧。 首先要在app/build.gradle中添加库依赖： 12345dependencies &#123; ... implementation &apos;com.android.support:design:27.1.1&apos; ...&#125; 然后在布局文件中添加控件： 12345678910111213141516171819202122232425262728293031323334...&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/til_email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;EditText android:id=\"@+id/email\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/prompt_email\" android:inputType=\"textEmailAddress\" android:maxLines=\"1\" android:singleLine=\"true\" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt;&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/til_pass\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:passwordToggleEnabled=\"true\"&gt; &lt;!--app:passwordToggleEnabled属性就是设置切换密码可见性的按钮--&gt; &lt;EditText android:id=\"@+id/password\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/prompt_password\" android:imeActionId=\"6\" android:imeActionLabel=\"@string/action_sign_in_short\" android:imeOptions=\"actionUnspecified\" android:inputType=\"textPassword\" android:maxLines=\"1\" android:singleLine=\"true\" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt;... 设置密码可见性的按钮已经设置完成，下面来写显示错误的逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class LoginActivity extends BaseActivity &#123; private EditText email; private EditText password; private Button login_btn; private TextInputLayout til_account; private TextInputLayout til_password; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; //此处省略初始化界面和设置控件实例的代码 login_btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String emailText = email.getText().toString(); String passText = password.getText().toString(); if(validateAccount(emailText) &amp; validatePassword(passText) //此处使用非短路与是因为有必要确保用户名和密码都得到检查，以便显示错误 )&#123; if(emailText.equals(\"xxx@yyy.com\") &amp;&amp; passText.equals(\"password\"))&#123; Intent intent = new Intent(LoginActivity.this, MainActivity.class); intent.putExtra(\"username\", emailText.substring(0, emailText.indexOf(\"@\"))); startActivity(intent); &#125;else&#123; Toast.makeText(LoginActivity.this, \"用户名或密码错误！\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;); &#125; /** * 显示错误提示，并获取焦点 * @param textInputLayout 要设置错误的TextInputLayout布局 * @param error 要显示的错误提示 */ private void showError(TextInputLayout textInputLayout, String error)&#123; textInputLayout.setError(error);//设置错误信息，注意此处只要error为非空则setErrorEnable()会自动设为true //确保可以设置焦点 textInputLayout.getEditText().setFocusable(true); textInputLayout.getEditText().setFocusableInTouchMode(true); //（要求）获取焦点 textInputLayout.getEditText().requestFocus(); &#125; /** * 验证用户名 * @param account 要验证的用户名 * @return boolean */ private boolean validateAccount(String account)&#123; if(account == null || account.equals(\"\") //更严谨地检验空字符串 )&#123; showError(til_account,\"用户名不能为空\"); return false; &#125; //检验正确别忘了取消错误显示 til_account.setErrorEnabled(false); return true; &#125; /** * 验证密码 * @param password 要验证的密码 * @return boolean */ private boolean validatePassword(String password) &#123; //与验证用户名相似，此处省略 &#125;&#125; 此处的几个知识点： View.setFocusable()与setFousableInTouchMode()的区别：顾名思义，前者用于物理输入时，比如鼠标键盘和遥控器等，而后者用于触控模式。不过个人觉得有点奇怪，为什么要把二者分开呢？或者说为什么不让setFocusable()也设置触控模式为真呢？ 据官方文档，TextInputLayout与其下的EditText可能并非是直接的父子关系，而是隔有中间层，所以不能调用EditText.getParent()方法获取TextInputLayout。此处并未用到，只是一起总结一下。 textInputLayout.setError(String)方法用于设置错误信息，注意此处只要字符串非空则setErrorEnable()会自动设为true。 Java中检验空字符串的几个方法： str == null || str.equals(&quot;&quot;)效率低 str == null || str == &quot;&quot;比较地址，效率高，慎用 str == null || str.length() &lt;= 0效率高 str == null || str.isEmpty()效率高，自Java SE 6.0支持 TextView也有类似的setError方法，不同的是它是在文本框右侧显示一张图片，并且弹出一个小弹窗显示设置的错误信息。 这时候登录界面的基本功能已经写好了，可以发现TextInputLayout提供的密码可见切换按钮在点击时还有动画，可以说是非常精致和贴心了。美中不足的是想要更新错误信息需要点击登录按钮才行，不是实时更新。更好的实现方式可以写成在焦点监听OnFocusChangeListener中更新，也可以写成在文本变化监听TextWatcher中更新。2.实现强制下线 接下来实现强制下线的逻辑。此处采用书中的框架，编写BaseActivity类来实现结束所有活动和弹出AlertDialog。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BaseActivity extends AppCompatActivity &#123; protected static LocalBroadcastManager manager; private ForceOfflineReceiver receiver; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityCollector.addActivity(this); manager = LocalBroadcastManager.getInstance(this); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); ActivityCollector.removeActivity(this); &#125; @Override protected void onResume() &#123; super.onResume(); receiver = new ForceOfflineReceiver(); manager.registerReceiver(receiver, new IntentFilter(\"com.example.zyf.broadcasttest2.FORCE_OFFLINE\")); &#125; @Override protected void onPause() &#123; super.onPause(); manager.unregisterReceiver(receiver); receiver = null; &#125; class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context, Intent intent) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(BaseActivity.this, R.style.Theme_AppCompat_Light_Dialog_Alert); builder.setTitle(\"强制下线警告\"); builder.setCancelable(false); builder.setMessage(\"您已被强制下线，请重新登录。\"); builder.setPositiveButton(\"好的\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActivityCollector.finishAll(); Intent intent = new Intent(context, LoginActivity.class); context.startActivity(intent); &#125; &#125;); builder.show(); &#125; &#125;&#125; 显然一个应用里只需要一个LocalBroadcastManager（虽然经测试多个也完全没问题），并且只需要处于栈顶（因为要弹出AlertDialog）的活动接收广播。所以我将LocalBroadcastManager设为static，并且按照书中的想法把注册与取消注册接收器的逻辑放在BaseActivity的onResume()和onPause()方法中。 此处主要的知识点就是AlertDialog.Builder的使用方法了。 setCancalable(boolean)：设置窗口是否可以取消（按返回键等），默认为可取消。 setMessage(int/CharSequence)：设置窗口显示的信息。 setPositiveButton(int/CharSequence, DialogInterface.OnClickListener)：设置显示给定文本和有给定监听器的“确定”按钮。 setNegativeButton(int/CharSequence, DialogInterface.OnClickListener)：设置显示给定文本和有给定监听器的“取消”按钮。 setNeutralButton(int/CharSequence, DialogInterface.OnClickListener)：设置显示给定文本和有给定监听器的“中性操作”按钮。 show()：创建并立即显示对话框。 setTitle(int/CharSequence)：设置窗口标题。 setView(int/View)：向窗口中添加自定义的View/布局。提示：也可以直接用Activity做对话框，然后在AndroidManifest.xml文件的&lt;activity&gt;标签中将主题设置为@android:style/Theme.Material.Dialog。 ==注意：==\\上面的AlertDialog.Builder(Context, int)中，Context只能是Activity，否则会报错：android.view.WindowManager$BadTokenException: Unable to add window – token null is not for an application。经过测试，直接使用onReceive(Context, Intent)中的Context属于android.app.Application，不是Activity类的。\\这个方法的另一个问题是，如果不用override的(Context, int)参数的方法可能报错：java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. 后记 在学习过程中我又尝试了一下焦点监听和文本变化监听，发现文本变化监听虽然有3个方法，但是不是很难实现。而焦点监听则并没有想象中那么简单，需要彻底理清每一种情况下焦点变化的过程，否则很容易出错。并且单靠文本变化监听或焦点监听也不足以实现跟常见登录界面相似的检查功能。在Android Studio默认的LoginActivity中有很多代码，不过因为不感兴趣和时间有限，进度等原因没有深入探究。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"实战","slug":"实战","permalink":"http://zyfAndroid.com/tags/实战/"},{"name":"Java","slug":"Java","permalink":"http://zyfAndroid.com/tags/Java/"},{"name":"TextInputLayout","slug":"TextInputLayout","permalink":"http://zyfAndroid.com/tags/TextInputLayout/"},{"name":"本地广播","slug":"本地广播","permalink":"http://zyfAndroid.com/tags/本地广播/"},{"name":"AlertDialog","slug":"AlertDialog","permalink":"http://zyfAndroid.com/tags/AlertDialog/"},{"name":"Broadcast","slug":"Broadcast","permalink":"http://zyfAndroid.com/tags/Broadcast/"},{"name":"字符串","slug":"字符串","permalink":"http://zyfAndroid.com/tags/字符串/"}]},{"title":"Android实战记（一）——用ConnectivityManager管理网络连接","slug":"Android实战记（一）——用ConnectivityManager管理网络连接","date":"2018-08-15T02:39:57.000Z","updated":"2018-08-17T03:19:01.404Z","comments":true,"path":"2018/08/15/Android实战记（一）——用ConnectivityManager管理网络连接/","link":"","permalink":"http://zyfAndroid.com/2018/08/15/Android实战记（一）——用ConnectivityManager管理网络连接/","excerpt":"","text":"最近看《第一行代码》看到了广播那一章，跟着书写到动态注册监听网络变化的那一节。其中一段代码如下：123456789101112131415public class MainActivity extends AppCompatActivity &#123; ... class NetworkChangeReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; ConnectivityManager connectionManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) &#123; Toast.makeText(context, \"network is available\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, \"network is unavailable\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125; 在参考官方文档)时，偶然发现上述代码中使用的Network.onAvailable()方法在API 28也就是Android P被摒弃了，官方转而推荐使用ConnectivityManager.NetworkCallbackAPI来监听网络变化。既然如此，我就想了解一下官方推荐的方法怎么使用。 查阅了种种资料之后，我写了第一个版本试试看（最小SDK为Android M）：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); connMgr.registerNetworkCallback(networkRequest, networkCallback); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); connMgr.unregisterNetworkCallback(networkCallback);//此处这句可以不写，可以理解为退出应用后会自动取消注册 &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); Toast.makeText(getBaseContext(), \"网络正常\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); Toast.makeText(getBaseContext(), \"网络已断开\", Toast.LENGTH_SHORT).show(); &#125; &#125; Java基础比较深或者对UI编写中给View实现监听器还有印象的朋友应该可以看出来在registerNetworkCallback()方法中直接使用匿名内部类也完全可以。 这一版在初步测试里没发现什么问题，于是突发奇想想做个拓展，没有网络时在界面上显示一个红色背景的文本框title，有网络时文本框自动消失。于是抱着试试看的心态写了第二版：123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; private TextView title; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); connMgr.registerNetworkCallback(networkRequest, networkCallback); &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); Toast.makeText(getBaseContext(), \"网络正常\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); Toast.makeText(getBaseContext(), \"网络已断开\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.VISIBLE); &#125; &#125;&#125; 结果收到了android.view.ViewRootImpl$CalledFromWrongThreadException，提示”Only the original thread that created a view hierarchy can touch its views.”，只有原始的创建了View结构的线程才能访问它的View。并且还提示错误来源于ConnectivityThread。经过又一番查询得知，Android应用的主线程控制UI的绘制，又称为UI线程，如果从其他线程访问UI将会遇到这个异常。那为什么更改title的可见性不是从主线程发出的呢？查询资料后发现，ConnectivityManager中封装了ConnectivityService，而ConnectivityService中会用到ConnectivityThread，所以是自动转到主线程之外了。 看来只能新建一个线程进行UI更新的相关操作了。这里使用了Handler来处理其他线程发给主线程更新UI的相关信息。这是第三版，其中把向主线程发送信息做成了方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MainActivity extends AppCompatActivity &#123; private NetworkRequest networkRequest; private ConnectivityManager connMgr; private ConnectivityManager.NetworkCallback networkCallback; private TextView title; private MyHandler handler; private final int CONN_AVAILABLE = 1; private final int CONN_UNAVAILABLE = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); handler = new MyHandler(); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); networkRequest = new NetworkRequest.Builder().build(); networkCallback = new NetworkCallbackImped(); MyThread thread = new MyThread(); new Thread(thread).start(); &#125; private void sendConnInfo(int info)&#123; Message message = new Message(); Bundle bundle = new Bundle(); bundle.putInt(\"conn\", info); message.setData(bundle); handler.sendMessage(message);//给handler发送连接可用的信息 &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); sendConnInfo(CONN_AVAILABLE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; class MyThread implements Runnable&#123; @Override public void run() &#123; connMgr.registerNetworkCallback(networkRequest, networkCallback); if (connMgr.getActiveNetworkInfo()==null)&#123; sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Bundle data = msg.getData(); int netConnectivity = data.getInt(\"conn\"); switch (netConnectivity)&#123; case CONN_UNAVAILABLE: Toast.makeText(getBaseContext(), \"好像没有网络了……\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.VISIBLE); break; case CONN_AVAILABLE: Toast.makeText(getBaseContext(), \"网络已恢复\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); break; default: break; &#125; &#125; &#125;&#125; 这一版解决了android.view.ViewRootImpl$CalledFromWrongThreadException，但是在更进一步的测试中发现了之前没发现的一个问题：开启了开发者模式中“始终保持数据网络”选项（下称“该选项”）时，在数据开启的状态下，开启WiFi时会出现最后结果为没有网络的情况。 仔细查看了官方文档后发现，onAvailable()方法是在框架连接了新的网络时调用： Called when the framework connects and has declared a new network ready for use. 而onLost()方法则是在框架失去某个网络连接时调用： Called when the framework has a hard loss of the network or when the graceful failure ends. 于是又在onLost()方法中加上了NetworkCapabilities.hasTransport()方法用于检测当前网络的类型。我们都知道，一般情况下，当开启数据的同时开启WiFi，系统会自动切换至WiFi，而经过多次实际检测，发现在开启该选项时，这个过程是先连接至WiFi（调用onAvailable()方法），大概过30秒左右再断开数据（调用onLost()方法），所以最后返回的结果是网络断开。 NetworkCapabilities.hasTransport()方法也是官方文档)中建议用于替代旧的获取当前网络类型方法NetworkInfo.getType()的方法，在实际使用中，可以发现新方法获取的信息确实比旧方法多，包括是否计费、是否使用VPN等均可以检测到。 所以在onLost()方法中还得判断一下是不是完全没有网络了，这一点可以用能否获取到NetCapabilities或NetInfo实例来判断。第4版代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity &#123; private ConnectivityManager connMgr; private TextView title; private MyHandler handler; private final int CONN_AVAILABLE = 1; private final int CONN_UNAVAILABLE = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); title = findViewById(R.id.title); handler = new MyHandler(); connMgr = (ConnectivityManager)getSystemService(CONNECTIVITY_SERVICE); MyThread thread = new MyThread();//新建Runnable实例 new Thread(thread).start();//启动新线程 &#125; //给handler发送连接可用的信息 private void sendConnInfo(int info)&#123; Message message = new Message(); Bundle bundle = new Bundle(); bundle.putInt(\"conn\", info); message.setData(bundle); handler.sendMessage(message); &#125; class NetworkCallbackImped extends ConnectivityManager.NetworkCallback&#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); sendConnInfo(CONN_AVAILABLE); &#125; @Override public void onLost(Network network) &#123; super.onLost(network); //此处遇到问题，开启开发者选项“始终开启移动数据网络”时，在开启数据时打开wifi，最终呈现是网络断开，但是能用NetworkCapabilities检测到wifi //查看文档发现onLost()方法是在有`network`断开而并非**所有`network`都断开**时，即有任意网络连接断开时即触发。 //onAvailable()方法是在有**新的**`network`可用时触发。 //经检测当wifi和移动网络同时连接时，先连接wifi，触发onAvailable()方法，但移动网络要过30s左右才断开，所以会触发onLost()方法。 //另有开启开发者选项“始终开启移动数据网络”时，数据WiFi双开时关闭WiFi后先调用`onAvailable()`方法后调用`onLost()`方法，且`NetworkCapabilities`为null的情况。 //结果发现出现此Bug的原因是关闭WiFi时刚好是之前讲的连接了WiFi后和断开移动网络前，所以只会调用`onLost()`方法。 //此处整理一下开启“始终开启移动数据网络”与否的双开网络变化情况。 //开启时：开着数据开WiFi时：先连接WiFi（但测试是数据），过约30s后断开数据。 双开关闭WiFi时：依据关WiFi的时机而定，在前述的30s内会无网络，30s之后马上切换至数据。 //关闭时：开着数据开WiFi时：先连接WiFi，再马上关闭数据。 双开关闭WiFi时：先关闭WiFi，再连接数据。 if (connMgr.getNetworkCapabilities(connMgr.getActiveNetwork()) == null) sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; class MyThread implements Runnable&#123; @Override public void run() &#123; connMgr.registerNetworkCallback(new NetworkRequest.Builder().build(), new NetworkCallbackImped()); //初始化时判断有无网络 if (connMgr.getActiveNetworkInfo()==null)&#123; sendConnInfo(CONN_UNAVAILABLE); &#125; &#125; &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Bundle data = msg.getData(); int netConnectivity = data.getInt(\"conn\"); switch (netConnectivity)&#123; case CONN_UNAVAILABLE: Toast.makeText(getBaseContext(), \"好像没有网络了……\", Toast.LENGTH_SHORT).show(); title.setText(\"好像没有网络了……\"); title.setVisibility(View.VISIBLE); break; case CONN_AVAILABLE: Toast.makeText(getBaseContext(), \"网络已恢复\", Toast.LENGTH_SHORT).show(); title.setVisibility(View.GONE); break; default: break; &#125; &#125; &#125;&#125; 其实最后还是有一个Bug没有解决，那就是开启“始终保持移动网络连接”时，在上述的30s内（即开启数据后开启WiFi时系统连接WiFi但未关闭数据时）关闭WiFi时，最后会检测不到网络（表现为最后调用的是onLost()且NetworkCapabilities和NetInfo均为null）。个人猜测可能是NetworkCallback的方法回调与上述两实例的获取之间存在时间差，也有可能是个体差异（测试机型为一加6，系统版本为ONEPLUS A6000_22_180810及其上一版）。 在进一步用Nubia Z11（Android 6.0.1）测试时，情况又有所变化。在未开启“始终保持移动网络连接”选项时，会出现类似一加6开启该选项的情况（即30s延迟）。但开启该选项后，双开后断开WiFi始终检测不到网络。 如果有朋友知晓原因，恳请不吝解惑！QQ: 504869112","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"实战","slug":"实战","permalink":"http://zyfAndroid.com/tags/实战/"},{"name":"网络","slug":"网络","permalink":"http://zyfAndroid.com/tags/网络/"},{"name":"ConnectivityManager","slug":"ConnectivityManager","permalink":"http://zyfAndroid.com/tags/ConnectivityManager/"},{"name":"NetworkCallback","slug":"NetworkCallback","permalink":"http://zyfAndroid.com/tags/NetworkCallback/"},{"name":"线程","slug":"线程","permalink":"http://zyfAndroid.com/tags/线程/"},{"name":"Handler","slug":"Handler","permalink":"http://zyfAndroid.com/tags/Handler/"}]},{"title":"Android第六课——活动的生命周期","slug":"Android第六课——活动的生命周期","date":"2018-08-14T01:52:21.000Z","updated":"2018-08-14T02:10:06.256Z","comments":true,"path":"2018/08/14/Android第六课——活动的生命周期/","link":"","permalink":"http://zyfAndroid.com/2018/08/14/Android第六课——活动的生命周期/","excerpt":"","text":"活动的生命周期返回栈Android使用任务(Task)来管理活动。一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈(Back Stack)。启动新活动时，该活动入栈，居于栈顶。按下Back键或调用finish()方法销毁活动时，处于栈顶的活动出栈，前一个入栈的活动居于栈顶。系统总是显示处于栈顶的活动给用户。 活动状态每个活动在生命周期内最多有4种状态。 运行状态：活动位于返回栈栈顶时。系统最不愿意回收这种状态的活动。 暂停状态：活动不再处于栈顶但依然可见时（比如处在对话框活动之下的活动）。系统也不愿意回收此类活动。 停止状态：活动不在栈顶且完全不可见时。系统仍会为其保存相应的状态和成员变量，但当需要内存时有可能会被系统回收。 销毁状态：活动从返回栈移除后。系统最倾向于回收此类活动。 活动生存期Activity类中提供了7个回调方法，可将活动的生命周期分成3个生存期。 完整生存期：在创建新活动时调用的onCreate()方法和销毁活动时调用的onDestory()方法之间的周期。 可见生存期：活动在由不可见变为可见时调用onStart()方法和在完全不可见时调用onStop()方法之间的周期。 前台生存期：活动在处于运行状态，准备好与用户交互时调用onResume()方法与活动被挂起，系统准备去启动或恢复另一活动时调用onPause()方法之间的周期。onPause()方法中通常释放一些消耗CPU的资源，保存一些关键数据，但方法执行速度一定要快。 onRestart()方法负责把活动从停止状态恢复为运行状态，即从onStop()后的活动执行，之后会执行onStart()方法。 在活动被回收前保存临时数据 Activity类中提供了一个onSaveInstanceState()回调方法，该方法可以保证在活动被回收之前一定会被调用。 该方法会携带一个Bundle类型的参数。Bundle提供了一系列方法用于保存数据，比如用putString()方法保存字符串，用putInt()方法保存整形数据，以此类推。 每个保存方法需要两个参数：键，相当于成员名，变量名，用于之后从Bundle中取值；第二个参数是要保存的值。 只需在onCreate()方法中传入之前保存的Bundle就可以在方法中取出之前保存的值。 可以把Bundle存放在Intent里实现跨活动传递数据。 活动的启动模式 主要是决定返回栈与返回栈中活动实例个数的设置，一共有四种，分别是standard,singleTop,singleTask,singleInstance，可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性选择启动模式。 standard模式下，每当启动一个新的活动，系统就会创建一个新的实例，它会入栈且处于栈顶。换句话说，standard模式对活动在返回栈中的唯一性不做任何保证。 用this.toString()方法可以把当前活动实例转换成字符串。 singleTop模式下，在启动活动时如果发现返回栈栈顶已经是该活动的一个实例则不再启动新活动。 singleTask模式下，在启动活动时如果发现返回栈中存在该活动实例则将其上所有活动都出栈使其置顶。 实际上我们在使用时发现，对于设置了”singleTask”启动模式的Activity，它在启动的时候，会先检测系统中属性值affinity等于它的属性值taskAffinity的task是否存在；如果存在这样的task，它就会在这个task中启动，否则就开启一个新的task。而taskAffinity默认情况下是应用的包名，即默认时并不会新建一个task。 因此，如果我们想要设置了”singleTask”启动模式的Activity在新的task中启动，就要为它设置一个独立的taskAffinity属性值。下面的代码中，应用程序的包名是com.fred.testactivity，我们将BActivity的启动模式设置成singleTask, 同时设置其taskAffinity属性为com.fred.testactivity.BActivity 。当BActivity启动时，会发现多了一个task 。代码如下：123456 &lt;activity android:name=\".BActivity\" android:label=\"@string/title_activity_b\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.fred.testactivity.BActivity\"&gt;&lt;/activity&gt; ==注== 此时该活动实例将会从停止/暂停状态恢复至运行状态，注意与活动生命周期结合理解。 singleInstance模式下，在整个系统中都只存在一个实例，因为系统会为该活动实例创建一个单独的返回栈。 使用getTaskId()可以获取当前任务ID的字符串。 关于活动的技巧知道当前界面对应的活动 用一个普通Java类作为AppCompatAvtivity的父类(e.g.BaseActivity)，再让所有活动都继承该类，在该类中重写onCreate()方法，打印一条以getClass().getSimpleName()作为内容的日志即可。getSimpleName()为获取当前类的简写名。 随时随地退出程序 新建一个Activity列表类，在其中写添加、去除Activity项以及借助finish()方法来结束列表中所有Activity的静态方法（e.g.finishAll()，静态是为了无需创建列表的实例） 在之前的BaseActivity中重写onCreate()和onDestroy()方法，加入在列表中添加、删除活动的方法调用。 接下来只需在需要结束所有活动的地方调用finishAll()方法即可。 也可以在finishAll()方法后加上杀掉当前进程的代码保证程序完全退出123android.os.Process.killProcess(android.os.Process.myPid());//killProcess()方法只能杀掉自己//通过myPid()方法获取当前进程的id 启动活动的更好方法 在活动中自己写一个actionStart()方法，在方法中通过传入的参数完成构建启动活动的Intent和调用startActivity()。 这样的好处在于可以清楚地看到需要传递的数据有哪些，而且在需要启动活动时只需调用该方法，无需再自己创建Intent等。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第六课","slug":"第六课","permalink":"http://zyfAndroid.com/tags/第六课/"},{"name":"Activity","slug":"Activity","permalink":"http://zyfAndroid.com/tags/Activity/"},{"name":"生命周期","slug":"生命周期","permalink":"http://zyfAndroid.com/tags/生命周期/"}]},{"title":"Android第五课——进阶组件之Intent初探","slug":"Android第五课——进阶组件之Intent初探","date":"2018-08-13T02:58:46.000Z","updated":"2018-08-13T04:59:42.849Z","comments":true,"path":"2018/08/13/Android第五课——进阶组件之Intent初探/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第五课——进阶组件之Intent初探/","excerpt":"","text":"Intent Intent 会在运行时将各个组件相互绑定（您可以将 Intent 视为从其他组件请求操作的信使），无论组件属于您的应用还是其他应用。 Intent是Android程序中各组件之间交互的重要方式，不仅可指明当前组件想要的动作，还能在不同组件间传递数据。 Intent包含的部分：组件名称，操作，数据，类别，Extra，标志 显式Intent 显式Intent指定明确的上下文和要转到的活动的class对象12345678Intent(Context packageContext, Class&lt;&gt; cls)//第二个参数指定想要启动的目标活动button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125; &#125;); 隐式Intent 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 隐式Intent不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它。创建隐式Intent时,Android系统通过将Intent的内容与在设备上其他应用的清单文件中声明的Intent过滤器进行比较，从而找到要启动的相应组件。如果Intent与Intent过滤器匹配，则系统将启动该组件，并向其传递Intent对象。如果多个Intent过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。 Intent过滤器是应用清单文件中的一个表达式，它指定该组件要接收的Intent类型。例如，通过为Activity声明Intent过滤器，您可以使其他应用能够直接使用某一特定类型的Intent启动Activity。同样，如果您没有为Activity声明任何Intent过滤器，则Activity只能通过显式Intent启动。只有Intent过滤器的action标签与catogory标签同时与Intent中指定的action和category匹配时活动才能响应该Intent。12345678910button1.setOnClickListener(new View.OnClickListener()&#123; @override public void onClick(View v)&#123; Intent intent = new Intent(\"com.example.activitytest.ACTION_START\"); //此处使用Intent的另一个构造函数，传入action字符串即可。 startActivity(intent); //\"android.intent.category.DEFAULT\"是一种默认的category，调用startActivity()方法时会自动将其添加到Intent中。 //或intent.addCategory(\"categoryName\");来添加category &#125;&#125;); 还可以利用隐式Intent启动其他应用程序内的活动，比如分享到其他App，打开网页等操作。 12345678910button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); //这是Android系统内置的一个动作，其常量值为android.intent.action.VIEW intent.setData(Uri.parse(\"http://www.baidu.com\")); //通过Uri.parse()方法将网址字符串解析成Uri对象，使用setData()方法把URI赋给Intent。（Intent的Data使用URI来表示） startActivity(intent); &#125; &#125;); 在AndroidManifest.xml文件中，可以为活动的Intent过滤器指定额外的&lt;data&gt;标签限定活动能响应的URI类型。只有&lt;data&gt;标签中指定的内容和Intent中携带的Data完全 一致时，当前活动才能够响应该Intent。以下是常用的标签内容： android:scheme。用于指定数据的协议部分，如http，geo(地理位置)，tel(拨打电话)等。 android:host。用于指定数据的主机名部分，如www.baidu.com。 android:port。用于指定数据的端口部分，一般紧随在主机名之后。 android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 可以使用Intent在启动活动的同时传递数据。 把需要传递的数据用putExtra()方法存放在Extra中 在另一个活动中用getIntent()方法取得传来的Intent 用getStringExtra()方法取回数据（其他类型类似） 也可以使用Intent给上一个活动返回数据。开发文档中有一个startActivityForResult()方法用于启动活动并向上一个活动返回数据。 给它传递一个启动活动用的Intent和一个唯一的requestCode参数 在另一个活动中用另一个Intent的Extra携带要返回的信息 用setResult()方法设置传回Intent和结果（RESULT_OK或RESULT_CANCELED） 用finish()方法结束当前活动并传回Intent 返回到上一个活动后会回调onActivityResult()方法，重写该方法添加从中得到返回的数据的逻辑 注意“返回到上一个活动时”包含所有返回的情况，如按Back键等，在按Back键返回的情况下需要重写onBackPressed()方法来执行setResult()方法。（此时super.onBackPressed()要写在最后） 更多Intent的例子会在之后的广播中遇到。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第五课","slug":"第五课","permalink":"http://zyfAndroid.com/tags/第五课/"},{"name":"Intent","slug":"Intent","permalink":"http://zyfAndroid.com/tags/Intent/"}]},{"title":"Android第四课——进阶组件之Toast与菜单","slug":"Android第四课——进阶组件之Toast与菜单","date":"2018-08-13T02:54:08.000Z","updated":"2018-08-13T02:56:45.845Z","comments":true,"path":"2018/08/13/Android第四课——进阶组件之Toast与菜单/","link":"","permalink":"http://zyfAndroid.com/2018/08/13/Android第四课——进阶组件之Toast与菜单/","excerpt":"","text":"进阶组件Toast12345678910//Toast是android.widget包内的类//makeText是Toast的静态方法，返回一个按照参数生成的ToastToast toast = Toast.makeText(context, text, duration);toast.show();//context相当于一个场景、情景，application/service/activity都是它的子类//text是要显示的文本//duration是持续时间，有Toast.LENGTH_SHORT和Toast.LENGTH_LONG两个内置常量可选Toast.makeText(FirstActivity.this, \"text\", Toast.LENGTH_SHORT).show();//先执行makeText()方法，其返回的Toast对象再执行show()方法 需要为Toast设置触发条件。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); //用findViewById()方法找到button1(view类)，再转换成button类 button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this, \"You clicked Button 1\", Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 改变Toast的位置 123456Toast toast = Toast.makeText(context, text, duration);toast.setGravity(Gravity.TOP|Gravity.LEFT, 0, 0);toast.show();//让Toast出现在容器的左上角//Gravity是Object的子类，有TOP/BOTTLE/LEFT/RIGHT/CENTER等常用int常量//第二、第三个参量是向右、向下移动Toast的偏移量 菜单菜单资源 需要在res/menu下建立菜单资源文件12345678&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/add_item\" android:title=\"Add\"/&gt; &lt;item android:id=\"@+id/remove_item\" android:title=\"Remove\"/&gt; &lt;/menu&gt; 部署菜单 重写onCreateOptionsMenu()方法创建菜单 123456public boolean onCreateOptionsMenu(Menu menu) &#123; //传入一个menu变量 getMenuInflater().inflate(R.menu.main, menu); //先调用getMenuInflater()方法得到MenuInflater对象 //再调用它的inflate()方法创建menu实例 return true;//方法中创建的菜单可见&#125; 重写onOptionsItemSelected()方法定义菜单响应事件 123456789101112public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123;//调用getItemId()方法得到被点击的菜单项ID case R.id.add_item: Toast.makeText(this, \"You clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, \"You clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: &#125; return true;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第四课","slug":"第四课","permalink":"http://zyfAndroid.com/tags/第四课/"},{"name":"Toast","slug":"Toast","permalink":"http://zyfAndroid.com/tags/Toast/"},{"name":"菜单","slug":"菜单","permalink":"http://zyfAndroid.com/tags/菜单/"}]},{"title":"Android第三课——测试与调试","slug":"Android第三课——日志工具Logcat的使用","date":"2018-08-12T05:27:37.000Z","updated":"2018-08-12T05:28:45.774Z","comments":true,"path":"2018/08/12/Android第三课——日志工具Logcat的使用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第三课——日志工具Logcat的使用/","excerpt":"","text":"测试与调试log类与logcat工具分类 Log.v()，对应verbose级别，最低的日志级别 Log.d()，对应debug级别，运行时会被去掉 Log.i()，对应info级别 Log.w()，对应warn级别 Log.e()，对应error级别用法 传入两个字符串参数 tag，一般传入当前的类名即可，用于对打印信息进行过滤 msg，想要打印的具体内容 输入logX按TAB即可补全对应的方法。 在onCreate()方法外输入logt按TAB即可生成当前类名的tag常量。 可以在logcat中用关键字进行进一步过滤日志，关键字支持正则表达式。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第三课","slug":"第三课","permalink":"http://zyfAndroid.com/tags/第三课/"},{"name":"日志","slug":"日志","permalink":"http://zyfAndroid.com/tags/日志/"},{"name":"logcat","slug":"logcat","permalink":"http://zyfAndroid.com/tags/logcat/"}]},{"title":"Android第二课——构建简单的应用","slug":"Android第二课——构建简单的应用","date":"2018-08-12T05:16:22.000Z","updated":"2018-08-12T05:18:38.234Z","comments":true,"path":"2018/08/12/Android第二课——构建简单的应用/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/Android第二课——构建简单的应用/","excerpt":"","text":"编写应用一个最简单的app主代码12345678public class HelloWorldActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.hello_world_layout); //R类是自动生成的，包含所有res目录下资源的id &#125;&#125; AppCompatActivity是一种向下兼容的Activity,是Activity的子类。Activity是Android系统提供的一个活动基类，所有活动必须继承它或它的子类才拥有活动的特性。 onCreate()方法是创建活动时必定会执行的方法。 setContentView()方法为当前活动引入布局。Android程序的设计讲究逻辑与视图分离，因此常在布局文件中编写界面，然后在活动中引入。 使用finish()方法销毁活动。 layout文件123456789101112131415161718192021222324&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/hello_world_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" tools:context=\"com.example.helloworld.HelloWorldActivity\"&gt; &lt;Button android:id=\"@+id/button_1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button 1\" /&gt;&lt;!--引用id用@id/name语法，定义id用@+id/name语法-&gt;&lt;!--TextView为文本--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" /&gt; &lt;/RelativeLayout&gt; 资源——字符串123&lt;resources&gt; &lt;string name=\"app_name\"&gt;HelloWorld&lt;/string&gt; &lt;/resources&gt; 引用资源的方式 代码中：通过R.string.app_name引用该字符串。 XML中：通过@string/app_name引用该字符串。\\其中string部分可替换成需要引用的资源类型，如layout,drawable等。例见AndroidManifest.xml文件。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"第二课","slug":"第二课","permalink":"http://zyfAndroid.com/tags/第二课/"},{"name":"资源","slug":"资源","permalink":"http://zyfAndroid.com/tags/资源/"}]},{"title":"Android第一课——初识Android","slug":"undefined-2018-08-12","date":"2018-08-12T04:24:28.000Z","updated":"2018-08-12T04:31:22.678Z","comments":true,"path":"2018/08/12/undefined-2018-08-12/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/undefined-2018-08-12/","excerpt":"","text":"Android四大组件Activity活动 包含应用所有看得见的东西Service服务 无法看到，在后台运行，退出应用仍可继续运行Broadcast Receiver广播接收器 允许应用接收来自各处的消息，如电话、短信等。应用也可发出自己的广播消息。Content Provider内容提供器 程序间共享数据的方法 Android工程的结构 AndroidManifest.xml12345678910111213141516171819202122&lt;!--注意application标签要写在所有其他标签之后--&gt;&lt;activity android:name=\".HelloWorldActivity\" android:label=\"Title\"&gt;&lt;!--程序包名可省略--&gt; &lt;intent-filter&gt; &lt;!--在intent-fliter中指示该应用可以处理的intent类型--&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;!--action和category两行表示该活动为主活动--&gt; &lt;!--可选用data标签指定当前活动能响应的数据类型--&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; ... &lt;/application&gt; build.gradle~\\build.gradle12345678910111213buildscript &#123; repositories &#123; jcenter()//jcenter是一个代码托管仓库，有这一行就可以引用上面的开源项目 &#125; dependencies &#123; classpath 'com.android.tools.build: gradle:2.2.0' &#125; &#125; allprojects &#123; repositories &#123; jcenter() &#125; &#125; ~\\app\\src\\build.gradle1234567891011121314151617181920212223242526272829303132apply plugin:'com.android.application' //表示这是应用程序模块//com.android.library表示库模块android &#123;//android闭包 compileSdkVersion 24 buildToolsVersion \"24.0.2\" defaultConfig &#123; applicationId \"com.example.helloworld\" //包名 minSdkVersion 15 //最低兼容版本 targetSdkVersion 24 //做过充分测试的版本 versionCode 1//版本号 versionName \"1.0\"//版本名 &#125; buildTypes &#123; release &#123; minifyEnabled false//是否对项目代码混淆 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; &#125; dependencies &#123; compile fileTree(dir:'libs', include:['*.jar']) //本地依赖声明 compile 'com.android.support:appcompat-v7:24.2.1' //远程依赖库 //com~support是域名 //app~v7是组名 //24.2.1是版本号 //库依赖：compile project(':libraryxxx') testCompile 'junit:junit:4.12'//测试用例库&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zyfAndroid.com/tags/Android/"},{"name":"工程","slug":"工程","permalink":"http://zyfAndroid.com/tags/工程/"},{"name":"结构","slug":"结构","permalink":"http://zyfAndroid.com/tags/结构/"},{"name":"第一课","slug":"第一课","permalink":"http://zyfAndroid.com/tags/第一课/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-12T02:24:45.393Z","updated":"2018-08-12T05:31:19.240Z","comments":true,"path":"2018/08/12/hello-world/","link":"","permalink":"http://zyfAndroid.com/2018/08/12/hello-world/","excerpt":"","text":"这里是我的Android开发学习笔记。我使用Android Studio + Java进行开发，以郭霖的《第一行代码》为主要参考资料，辅以Android官方文档及网上其他资料。 由于本人纯小白，也会在此发表一些Java学习笔记。因为本人处在不断学习的阶段，之前发表的文章也可能会更新内容。 本博客使用Hexo 搭建。","categories":[],"tags":[]}]}